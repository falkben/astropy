


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.stats.funcs &#8212; Astropy v5.2.dev94+gb1133d712.d20220509</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
  <meta name="robots" content="noindex, nofollow">
  
  
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v5.2.dev94+gb1133d712.d20220509</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.stats.funcs</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains simple statistical algorithms that are</span>
<span class="sd">straightforwardly implemented as a single python function (or family of</span>
<span class="sd">functions).</span>

<span class="sd">This module should generally not be used directly.  Everything in</span>
<span class="sd">`__all__` is imported into `astropy.stats`, and hence that package</span>
<span class="sd">should be used for access.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_stats</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaussian_fwhm_to_sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian_sigma_to_fwhm&#39;</span><span class="p">,</span>
           <span class="s1">&#39;binom_conf_interval&#39;</span><span class="p">,</span> <span class="s1">&#39;binned_binom_proportion&#39;</span><span class="p">,</span>
           <span class="s1">&#39;poisson_conf_interval&#39;</span><span class="p">,</span> <span class="s1">&#39;median_absolute_deviation&#39;</span><span class="p">,</span> <span class="s1">&#39;mad_std&#39;</span><span class="p">,</span>
           <span class="s1">&#39;signal_to_noise_oir_ccd&#39;</span><span class="p">,</span> <span class="s1">&#39;bootstrap&#39;</span><span class="p">,</span> <span class="s1">&#39;kuiper&#39;</span><span class="p">,</span> <span class="s1">&#39;kuiper_two&#39;</span><span class="p">,</span>
           <span class="s1">&#39;kuiper_false_positive_probability&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf_from_intervals&#39;</span><span class="p">,</span>
           <span class="s1">&#39;interval_overlap_length&#39;</span><span class="p">,</span> <span class="s1">&#39;histogram_intervals&#39;</span><span class="p">,</span> <span class="s1">&#39;fold_intervals&#39;</span><span class="p">]</span>

<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;binned_binom_proportion&#39;</span><span class="p">]</span>
<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;binom_conf_interval&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scipy&#39;</span><span class="p">],</span>
                        <span class="s1">&#39;poisson_conf_interval&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scipy&#39;</span><span class="p">]}</span>


<span class="n">gaussian_sigma_to_fwhm</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor with which to multiply Gaussian 1-sigma standard deviation to</span>
<span class="sd">convert it to full width at half maximum (FWHM).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">gaussian_fwhm_to_sigma</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">gaussian_sigma_to_fwhm</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Factor with which to multiply Gaussian full width at half maximum (FWHM)</span>
<span class="sd">to convert it to 1-sigma standard deviation.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># NUMPY_LT_1_18</span>
<span class="k">def</span> <span class="nf">_expand_dims</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the shape of an array.</span>

<span class="sd">    Insert a new axis that will appear at the `axis` position in the</span>
<span class="sd">    expanded array shape.</span>

<span class="sd">    This function allows for tuple axis arguments.</span>
<span class="sd">    ``numpy.expand_dims`` currently does not allow that, but it will in</span>
<span class="sd">    numpy v1.18 (https://github.com/numpy/numpy/pull/14051).</span>
<span class="sd">    ``_expand_dims`` can be replaced with ``numpy.expand_dims`` when the</span>
<span class="sd">    minimum support numpy version is v1.18.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int or tuple of int</span>
<span class="sd">        Position in the expanded axes where the new axis (or axes) is</span>
<span class="sd">        placed.  A tuple of axes is now supported.  Out of range axes as</span>
<span class="sd">        described above are now forbidden and raise an `AxisError`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        View of ``data`` with the number of dimensions increased.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>

    <span class="n">out_ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">numeric</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out_ndim</span><span class="p">)</span>

    <span class="n">shape_it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">next</span><span class="p">(</span><span class="n">shape_it</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out_ndim</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>


<div class="viewcode-block" id="binom_conf_interval"><a class="viewcode-back" href="../../../api/astropy.stats.binom_conf_interval.html#astropy.stats.binom_conf_interval">[docs]</a><span class="k">def</span> <span class="nf">binom_conf_interval</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">confidence_level</span><span class="o">=</span><span class="mf">0.68269</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;wilson&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Binomial proportion confidence interval given k successes,</span>
<span class="sd">    n trials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k : int or numpy.ndarray</span>
<span class="sd">        Number of successes (0 &lt;= ``k`` &lt;= ``n``).</span>
<span class="sd">    n : int or numpy.ndarray</span>
<span class="sd">        Number of trials (``n`` &gt; 0).  If both ``k`` and ``n`` are arrays,</span>
<span class="sd">        they must have the same shape.</span>
<span class="sd">    confidence_level : float, optional</span>
<span class="sd">        Desired probability content of interval. Default is 0.68269,</span>
<span class="sd">        corresponding to 1 sigma in a 1-dimensional Gaussian distribution.</span>
<span class="sd">        Confidence level must be in range [0, 1].</span>
<span class="sd">    interval : {&#39;wilson&#39;, &#39;jeffreys&#39;, &#39;flat&#39;, &#39;wald&#39;}, optional</span>
<span class="sd">        Formula used for confidence interval. See notes for details.  The</span>
<span class="sd">        ``&#39;wilson&#39;`` and ``&#39;jeffreys&#39;`` intervals generally give similar</span>
<span class="sd">        results, while &#39;flat&#39; is somewhat different, especially for small</span>
<span class="sd">        values of ``n``.  ``&#39;wilson&#39;`` should be somewhat faster than</span>
<span class="sd">        ``&#39;flat&#39;`` or ``&#39;jeffreys&#39;``.  The &#39;wald&#39; interval is generally not</span>
<span class="sd">        recommended.  It is provided for comparison purposes.  Default is</span>
<span class="sd">        ``&#39;wilson&#39;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    conf_interval : ndarray</span>
<span class="sd">        ``conf_interval[0]`` and ``conf_interval[1]`` correspond to the lower</span>
<span class="sd">        and upper limits, respectively, for each element in ``k``, ``n``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In situations where a probability of success is not known, it can</span>
<span class="sd">    be estimated from a number of trials (n) and number of</span>
<span class="sd">    observed successes (k). For example, this is done in Monte</span>
<span class="sd">    Carlo experiments designed to estimate a detection efficiency. It</span>
<span class="sd">    is simple to take the sample proportion of successes (k/n)</span>
<span class="sd">    as a reasonable best estimate of the true probability</span>
<span class="sd">    :math:`\epsilon`. However, deriving an accurate confidence</span>
<span class="sd">    interval on :math:`\epsilon` is non-trivial. There are several</span>
<span class="sd">    formulas for this interval (see [1]_). Four intervals are implemented</span>
<span class="sd">    here:</span>

<span class="sd">    **1. The Wilson Interval.** This interval, attributed to Wilson [2]_,</span>
<span class="sd">    is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        CI_{\rm Wilson} = \frac{k + \kappa^2/2}{n + \kappa^2}</span>
<span class="sd">        \pm \frac{\kappa n^{1/2}}{n + \kappa^2}</span>
<span class="sd">        ((\hat{\epsilon}(1 - \hat{\epsilon}) + \kappa^2/(4n))^{1/2}</span>

<span class="sd">    where :math:`\hat{\epsilon} = k / n` and :math:`\kappa` is the</span>
<span class="sd">    number of standard deviations corresponding to the desired</span>
<span class="sd">    confidence interval for a *normal* distribution (for example,</span>
<span class="sd">    1.0 for a confidence interval of 68.269%). For a</span>
<span class="sd">    confidence interval of 100(1 - :math:`\alpha`)%,</span>

<span class="sd">    .. math::</span>

<span class="sd">        \kappa = \Phi^{-1}(1-\alpha/2) = \sqrt{2}{\rm erf}^{-1}(1-\alpha).</span>

<span class="sd">    **2. The Jeffreys Interval.** This interval is derived by applying</span>
<span class="sd">    Bayes&#39; theorem to the binomial distribution with the</span>
<span class="sd">    noninformative Jeffreys prior [3]_, [4]_. The noninformative Jeffreys</span>
<span class="sd">    prior is the Beta distribution, Beta(1/2, 1/2), which has the density</span>
<span class="sd">    function</span>

<span class="sd">    .. math::</span>

<span class="sd">        f(\epsilon) = \pi^{-1} \epsilon^{-1/2}(1-\epsilon)^{-1/2}.</span>

<span class="sd">    The justification for this prior is that it is invariant under</span>
<span class="sd">    reparameterizations of the binomial proportion.</span>
<span class="sd">    The posterior density function is also a Beta distribution: Beta(k</span>
<span class="sd">    + 1/2, n - k + 1/2). The interval is then chosen so that it is</span>
<span class="sd">    *equal-tailed*: Each tail (outside the interval) contains</span>
<span class="sd">    :math:`\alpha`/2 of the posterior probability, and the interval</span>
<span class="sd">    itself contains 1 - :math:`\alpha`. This interval must be</span>
<span class="sd">    calculated numerically. Additionally, when k = 0 the lower limit</span>
<span class="sd">    is set to 0 and when k = n the upper limit is set to 1, so that in</span>
<span class="sd">    these cases, there is only one tail containing :math:`\alpha`/2</span>
<span class="sd">    and the interval itself contains 1 - :math:`\alpha`/2 rather than</span>
<span class="sd">    the nominal 1 - :math:`\alpha`.</span>

<span class="sd">    **3. A Flat prior.** This is similar to the Jeffreys interval,</span>
<span class="sd">    but uses a flat (uniform) prior on the binomial proportion</span>
<span class="sd">    over the range 0 to 1 rather than the reparametrization-invariant</span>
<span class="sd">    Jeffreys prior.  The posterior density function is a Beta distribution:</span>
<span class="sd">    Beta(k + 1, n - k + 1).  The same comments about the nature of the</span>
<span class="sd">    interval (equal-tailed, etc.) also apply to this option.</span>

<span class="sd">    **4. The Wald Interval.** This interval is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">       CI_{\rm Wald} = \hat{\epsilon} \pm</span>
<span class="sd">       \kappa \sqrt{\frac{\hat{\epsilon}(1-\hat{\epsilon})}{n}}</span>

<span class="sd">    The Wald interval gives acceptable results in some limiting</span>
<span class="sd">    cases. Particularly, when n is very large, and the true proportion</span>
<span class="sd">    :math:`\epsilon` is not &quot;too close&quot; to 0 or 1. However, as the</span>
<span class="sd">    later is not verifiable when trying to estimate :math:`\epsilon`,</span>
<span class="sd">    this is not very helpful. Its use is not recommended, but it is</span>
<span class="sd">    provided here for comparison purposes due to its prevalence in</span>
<span class="sd">    everyday practical statistics.</span>

<span class="sd">    This function requires ``scipy`` for all interval types.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Brown, Lawrence D.; Cai, T. Tony; DasGupta, Anirban (2001).</span>
<span class="sd">       &quot;Interval Estimation for a Binomial Proportion&quot;. Statistical</span>
<span class="sd">       Science 16 (2): 101-133. doi:10.1214/ss/1009213286</span>

<span class="sd">    .. [2] Wilson, E. B. (1927). &quot;Probable inference, the law of</span>
<span class="sd">       succession, and statistical inference&quot;. Journal of the American</span>
<span class="sd">       Statistical Association 22: 209-212.</span>

<span class="sd">    .. [3] Jeffreys, Harold (1946). &quot;An Invariant Form for the Prior</span>
<span class="sd">       Probability in Estimation Problems&quot;. Proc. R. Soc. Lond.. A 24 186</span>
<span class="sd">       (1007): 453-461. doi:10.1098/rspa.1946.0056</span>

<span class="sd">    .. [4] Jeffreys, Harold (1998). Theory of Probability. Oxford</span>
<span class="sd">       University Press, 3rd edition. ISBN 978-0198503682</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Integer inputs return an array with shape (2,):</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval(4, 5, interval=&#39;wilson&#39;)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([0.57921724, 0.92078259])</span>

<span class="sd">    Arrays of arbitrary dimension are supported. The Wilson and Jeffreys</span>
<span class="sd">    intervals give similar results, even for small k, n:</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval([1, 2], 5, interval=&#39;wilson&#39;)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[0.07921741, 0.21597328],</span>
<span class="sd">           [0.42078276, 0.61736012]])</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval([1, 2,], 5, interval=&#39;jeffreys&#39;)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[0.0842525 , 0.21789949],</span>
<span class="sd">           [0.42218001, 0.61753691]])</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval([1, 2], 5, interval=&#39;flat&#39;)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[0.12139799, 0.24309021],</span>
<span class="sd">           [0.45401727, 0.61535699]])</span>

<span class="sd">    In contrast, the Wald interval gives poor results for small k, n.</span>
<span class="sd">    For k = 0 or k = n, the interval always has zero length.</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval([1, 2], 5, interval=&#39;wald&#39;)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[0.02111437, 0.18091075],</span>
<span class="sd">           [0.37888563, 0.61908925]])</span>

<span class="sd">    For confidence intervals approaching 1, the Wald interval for</span>
<span class="sd">    0 &lt; k &lt; n can give intervals that extend outside [0, 1]:</span>

<span class="sd">    &gt;&gt;&gt; binom_conf_interval([1, 2], 5, interval=&#39;wald&#39;, confidence_level=0.99)  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[-0.26077835, -0.16433593],</span>
<span class="sd">           [ 0.66077835,  0.96433593]])</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>
    <span class="k">if</span> <span class="n">confidence_level</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">confidence_level</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;confidence_level must be between 0. and 1.&#39;</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">confidence_level</span>

    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n must be positive&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;k must be in {0, 1, .., n}&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;wilson&#39;</span> <span class="ow">or</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;wald&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erfinv</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">erfinv</span><span class="p">(</span><span class="n">confidence_level</span><span class="p">),</span> <span class="mf">1.e10</span><span class="p">)</span>  <span class="c1"># Avoid overflows.</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">n</span>

        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;wilson&#39;</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">halflength</span> <span class="o">=</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>
            <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">midpoint</span> <span class="o">-</span> <span class="n">halflength</span><span class="p">,</span>
                                      <span class="n">midpoint</span> <span class="o">+</span> <span class="n">halflength</span><span class="p">])</span>

            <span class="c1"># Correct intervals out of range due to floating point errors.</span>
            <span class="n">conf_interval</span><span class="p">[</span><span class="n">conf_interval</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">conf_interval</span><span class="p">[</span><span class="n">conf_interval</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">halflength</span> <span class="o">=</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">midpoint</span> <span class="o">-</span> <span class="n">halflength</span><span class="p">,</span>
                                      <span class="n">midpoint</span> <span class="o">+</span> <span class="n">halflength</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;jeffreys&#39;</span> <span class="ow">or</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">betaincinv</span>

        <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;jeffreys&#39;</span><span class="p">:</span>
            <span class="n">lowerbound</span> <span class="o">=</span> <span class="n">betaincinv</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="n">upperbound</span> <span class="o">=</span> <span class="n">betaincinv</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowerbound</span> <span class="o">=</span> <span class="n">betaincinv</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="n">upperbound</span> <span class="o">=</span> <span class="n">betaincinv</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># Set lower or upper bound to k/n when k/n = 0 or 1</span>
        <span class="c1">#  We have to treat the special case of k/n being scalars,</span>
        <span class="c1">#  which is an ugly kludge</span>
        <span class="k">if</span> <span class="n">lowerbound</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lowerbound</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">upperbound</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowerbound</span><span class="p">[</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">upperbound</span><span class="p">[</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lowerbound</span><span class="p">,</span> <span class="n">upperbound</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unrecognized interval: </span><span class="si">{</span><span class="n">interval</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">conf_interval</span></div>


<div class="viewcode-block" id="binned_binom_proportion"><a class="viewcode-back" href="../../../api/astropy.stats.binned_binom_proportion.html#astropy.stats.binned_binom_proportion">[docs]</a><span class="k">def</span> <span class="nf">binned_binom_proportion</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">confidence_level</span><span class="o">=</span><span class="mf">0.68269</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;wilson&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binomial proportion and confidence interval in bins of a continuous</span>
<span class="sd">    variable ``x``.</span>

<span class="sd">    Given a set of datapoint pairs where the ``x`` values are</span>
<span class="sd">    continuously distributed and the ``success`` values are binomial</span>
<span class="sd">    (&quot;success / failure&quot; or &quot;true / false&quot;), place the pairs into</span>
<span class="sd">    bins according to ``x`` value and calculate the binomial proportion</span>
<span class="sd">    (fraction of successes) and confidence interval in each bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : sequence</span>
<span class="sd">        Values.</span>
<span class="sd">    success : sequence of bool</span>
<span class="sd">        Success (`True`) or failure (`False`) corresponding to each value</span>
<span class="sd">        in ``x``.  Must be same length as ``x``.</span>
<span class="sd">    bins : int or sequence of scalar, optional</span>
<span class="sd">        If bins is an int, it defines the number of equal-width bins</span>
<span class="sd">        in the given range (10, by default). If bins is a sequence, it</span>
<span class="sd">        defines the bin edges, including the rightmost edge, allowing</span>
<span class="sd">        for non-uniform bin widths (in this case, &#39;range&#39; is ignored).</span>
<span class="sd">    range : (float, float), optional</span>
<span class="sd">        The lower and upper range of the bins. If `None` (default),</span>
<span class="sd">        the range is set to ``(x.min(), x.max())``. Values outside the</span>
<span class="sd">        range are ignored.</span>
<span class="sd">    confidence_level : float, optional</span>
<span class="sd">        Must be in range [0, 1].</span>
<span class="sd">        Desired probability content in the confidence</span>
<span class="sd">        interval ``(p - perr[0], p + perr[1])`` in each bin. Default is</span>
<span class="sd">        0.68269.</span>
<span class="sd">    interval : {&#39;wilson&#39;, &#39;jeffreys&#39;, &#39;flat&#39;, &#39;wald&#39;}, optional</span>
<span class="sd">        Formula used to calculate confidence interval on the</span>
<span class="sd">        binomial proportion in each bin. See `binom_conf_interval` for</span>
<span class="sd">        definition of the intervals.  The &#39;wilson&#39;, &#39;jeffreys&#39;,</span>
<span class="sd">        and &#39;flat&#39; intervals generally give similar results.  &#39;wilson&#39;</span>
<span class="sd">        should be somewhat faster, while &#39;jeffreys&#39; and &#39;flat&#39; are</span>
<span class="sd">        marginally superior, but differ in the assumed prior.</span>
<span class="sd">        The &#39;wald&#39; interval is generally not recommended.</span>
<span class="sd">        It is provided for comparison purposes. Default is &#39;wilson&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bin_ctr : ndarray</span>
<span class="sd">        Central value of bins. Bins without any entries are not returned.</span>
<span class="sd">    bin_halfwidth : ndarray</span>
<span class="sd">        Half-width of each bin such that ``bin_ctr - bin_halfwidth`` and</span>
<span class="sd">        ``bin_ctr + bins_halfwidth`` give the left and right side of each bin,</span>
<span class="sd">        respectively.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Efficiency in each bin.</span>
<span class="sd">    perr : ndarray</span>
<span class="sd">        2-d array of shape (2, len(p)) representing the upper and lower</span>
<span class="sd">        uncertainty on p in each bin.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function requires ``scipy`` for all interval types.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    binom_conf_interval : Function used to estimate confidence interval in</span>
<span class="sd">                          each bin.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we wish to estimate the efficiency of a survey in</span>
<span class="sd">    detecting astronomical sources as a function of magnitude (i.e.,</span>
<span class="sd">    the probability of detecting a source given its magnitude). In a</span>
<span class="sd">    realistic case, we might prepare a large number of sources with</span>
<span class="sd">    randomly selected magnitudes, inject them into simulated images,</span>
<span class="sd">    and then record which were detected at the end of the reduction</span>
<span class="sd">    pipeline. As a toy example, we generate 100 data points with</span>
<span class="sd">    randomly selected magnitudes between 20 and 30 and &quot;observe&quot; them</span>
<span class="sd">    with a known detection function (here, the error function, with</span>
<span class="sd">    50% detection probability at magnitude 25):</span>

<span class="sd">    &gt;&gt;&gt; from scipy.special import erf</span>
<span class="sd">    &gt;&gt;&gt; from scipy.stats.distributions import binom</span>
<span class="sd">    &gt;&gt;&gt; def true_efficiency(x):</span>
<span class="sd">    ...     return 0.5 - 0.5 * erf((x - 25.) / 2.)</span>
<span class="sd">    &gt;&gt;&gt; mag = 20. + 10. * np.random.rand(100)</span>
<span class="sd">    &gt;&gt;&gt; detected = binom.rvs(1, true_efficiency(mag))</span>
<span class="sd">    &gt;&gt;&gt; bins, binshw, p, perr = binned_binom_proportion(mag, detected, bins=20)</span>
<span class="sd">    &gt;&gt;&gt; plt.errorbar(bins, p, xerr=binshw, yerr=perr, ls=&#39;none&#39;, marker=&#39;o&#39;,</span>
<span class="sd">    ...              label=&#39;estimate&#39;)</span>

<span class="sd">    .. plot::</span>

<span class="sd">       import numpy as np</span>
<span class="sd">       from scipy.special import erf</span>
<span class="sd">       from scipy.stats.distributions import binom</span>
<span class="sd">       import matplotlib.pyplot as plt</span>
<span class="sd">       from astropy.stats import binned_binom_proportion</span>
<span class="sd">       def true_efficiency(x):</span>
<span class="sd">           return 0.5 - 0.5 * erf((x - 25.) / 2.)</span>
<span class="sd">       np.random.seed(400)</span>
<span class="sd">       mag = 20. + 10. * np.random.rand(100)</span>
<span class="sd">       np.random.seed(600)</span>
<span class="sd">       detected = binom.rvs(1, true_efficiency(mag))</span>
<span class="sd">       bins, binshw, p, perr = binned_binom_proportion(mag, detected, bins=20)</span>
<span class="sd">       plt.errorbar(bins, p, xerr=binshw, yerr=perr, ls=&#39;none&#39;, marker=&#39;o&#39;,</span>
<span class="sd">                    label=&#39;estimate&#39;)</span>
<span class="sd">       X = np.linspace(20., 30., 1000)</span>
<span class="sd">       plt.plot(X, true_efficiency(X), label=&#39;true efficiency&#39;)</span>
<span class="sd">       plt.ylim(0., 1.)</span>
<span class="sd">       plt.title(&#39;Detection efficiency vs magnitude&#39;)</span>
<span class="sd">       plt.xlabel(&#39;Magnitude&#39;)</span>
<span class="sd">       plt.ylabel(&#39;Detection efficiency&#39;)</span>
<span class="sd">       plt.legend()</span>
<span class="sd">       plt.show()</span>

<span class="sd">    The above example uses the Wilson confidence interval to calculate</span>
<span class="sd">    the uncertainty ``perr`` in each bin (see the definition of various</span>
<span class="sd">    confidence intervals in `binom_conf_interval`). A commonly used</span>
<span class="sd">    alternative is the Wald interval. However, the Wald interval can</span>
<span class="sd">    give nonsensical uncertainties when the efficiency is near 0 or 1,</span>
<span class="sd">    and is therefore **not** recommended. As an illustration, the</span>
<span class="sd">    following example shows the same data as above but uses the Wald</span>
<span class="sd">    interval rather than the Wilson interval to calculate ``perr``:</span>

<span class="sd">    &gt;&gt;&gt; bins, binshw, p, perr = binned_binom_proportion(mag, detected, bins=20,</span>
<span class="sd">    ...                                                 interval=&#39;wald&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.errorbar(bins, p, xerr=binshw, yerr=perr, ls=&#39;none&#39;, marker=&#39;o&#39;,</span>
<span class="sd">    ...              label=&#39;estimate&#39;)</span>

<span class="sd">    .. plot::</span>

<span class="sd">       import numpy as np</span>
<span class="sd">       from scipy.special import erf</span>
<span class="sd">       from scipy.stats.distributions import binom</span>
<span class="sd">       import matplotlib.pyplot as plt</span>
<span class="sd">       from astropy.stats import binned_binom_proportion</span>
<span class="sd">       def true_efficiency(x):</span>
<span class="sd">           return 0.5 - 0.5 * erf((x - 25.) / 2.)</span>
<span class="sd">       np.random.seed(400)</span>
<span class="sd">       mag = 20. + 10. * np.random.rand(100)</span>
<span class="sd">       np.random.seed(600)</span>
<span class="sd">       detected = binom.rvs(1, true_efficiency(mag))</span>
<span class="sd">       bins, binshw, p, perr = binned_binom_proportion(mag, detected, bins=20,</span>
<span class="sd">                                                       interval=&#39;wald&#39;)</span>
<span class="sd">       plt.errorbar(bins, p, xerr=binshw, yerr=perr, ls=&#39;none&#39;, marker=&#39;o&#39;,</span>
<span class="sd">                    label=&#39;estimate&#39;)</span>
<span class="sd">       X = np.linspace(20., 30., 1000)</span>
<span class="sd">       plt.plot(X, true_efficiency(X), label=&#39;true efficiency&#39;)</span>
<span class="sd">       plt.ylim(0., 1.)</span>
<span class="sd">       plt.title(&#39;The Wald interval can give nonsensical uncertainties&#39;)</span>
<span class="sd">       plt.xlabel(&#39;Magnitude&#39;)</span>
<span class="sd">       plt.ylabel(&#39;Detection efficiency&#39;)</span>
<span class="sd">       plt.legend()</span>
<span class="sd">       plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">success</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">success</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sizes of x and success must match&#39;</span><span class="p">)</span>

    <span class="c1"># Put values into a histogram (`n`). Put &quot;successful&quot; values</span>
    <span class="c1"># into a second histogram (`k`) with identical binning.</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">)</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">success</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">bin_ctr</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">bin_halfwidth</span> <span class="o">=</span> <span class="n">bin_ctr</span> <span class="o">-</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Remove bins with zero entries.</span>
    <span class="n">valid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">bin_ctr</span> <span class="o">=</span> <span class="n">bin_ctr</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="n">bin_halfwidth</span> <span class="o">=</span> <span class="n">bin_halfwidth</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">valid</span><span class="p">]</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">k</span> <span class="o">/</span> <span class="n">n</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">binom_conf_interval</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">confidence_level</span><span class="o">=</span><span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
    <span class="n">perr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bounds</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bin_ctr</span><span class="p">,</span> <span class="n">bin_halfwidth</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">perr</span></div>


<span class="k">def</span> <span class="nf">_check_poisson_conf_inputs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only sigma=1 supported for interval </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">background</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;background not supported for interval </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">confidence_level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;confidence_level not supported for interval </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="poisson_conf_interval"><a class="viewcode-back" href="../../../api/astropy.stats.poisson_conf_interval.html#astropy.stats.poisson_conf_interval">[docs]</a><span class="k">def</span> <span class="nf">poisson_conf_interval</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;root-n&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">confidence_level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Poisson parameter confidence interval given observed counts</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or numpy.ndarray</span>
<span class="sd">        Number of counts (0 &lt;= ``n``).</span>
<span class="sd">    interval : {&#39;root-n&#39;,&#39;root-n-0&#39;,&#39;pearson&#39;,&#39;sherpagehrels&#39;,&#39;frequentist-confidence&#39;, &#39;kraft-burrows-nousek&#39;}, optional</span>
<span class="sd">        Formula used for confidence interval. See notes for details.</span>
<span class="sd">        Default is ``&#39;root-n&#39;``.</span>
<span class="sd">    sigma : float, optional</span>
<span class="sd">        Number of sigma for confidence interval; only supported for</span>
<span class="sd">        the &#39;frequentist-confidence&#39; mode.</span>
<span class="sd">    background : float, optional</span>
<span class="sd">        Number of counts expected from the background; only supported for</span>
<span class="sd">        the &#39;kraft-burrows-nousek&#39; mode. This number is assumed to be determined</span>
<span class="sd">        from a large region so that the uncertainty on its value is negligible.</span>
<span class="sd">    confidence_level : float, optional</span>
<span class="sd">        Confidence level between 0 and 1; only supported for the</span>
<span class="sd">        &#39;kraft-burrows-nousek&#39; mode.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    conf_interval : ndarray</span>
<span class="sd">        ``conf_interval[0]`` and ``conf_interval[1]`` correspond to the lower</span>
<span class="sd">        and upper limits, respectively, for each element in ``n``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The &quot;right&quot; confidence interval to use for Poisson data is a</span>
<span class="sd">    matter of debate. The CDF working group `recommends</span>
<span class="sd">    &lt;https://web.archive.org/web/20210222093249/https://www-cdf.fnal.gov/physics/statistics/notes/pois_eb.txt&gt;`_</span>
<span class="sd">    using root-n throughout, largely in the interest of</span>
<span class="sd">    comprehensibility, but discusses other possibilities. The ATLAS</span>
<span class="sd">    group also discusses several</span>
<span class="sd">    possibilities but concludes that no single representation is</span>
<span class="sd">    suitable for all cases.  The suggestion has also been `floated</span>
<span class="sd">    &lt;https://ui.adsabs.harvard.edu/abs/2012EPJP..127...24A&gt;`_ that error</span>
<span class="sd">    bars should be attached to theoretical predictions instead of</span>
<span class="sd">    observed data, which this function will not help with (but it&#39;s</span>
<span class="sd">    easy; then you really should use the square root of the theoretical</span>
<span class="sd">    prediction).</span>

<span class="sd">    The intervals implemented here are:</span>

<span class="sd">    **1. &#39;root-n&#39;** This is a very widely used standard rule derived</span>
<span class="sd">    from the maximum-likelihood estimator for the mean of the Poisson</span>
<span class="sd">    process. While it produces questionable results for small n and</span>
<span class="sd">    outright wrong results for n=0, it is standard enough that people are</span>
<span class="sd">    (supposedly) used to interpreting these wonky values. The interval is</span>

<span class="sd">    .. math::</span>

<span class="sd">        CI = (n-\sqrt{n}, n+\sqrt{n})</span>

<span class="sd">    **2. &#39;root-n-0&#39;** This is identical to the above except that where</span>
<span class="sd">    n is zero the interval returned is (0,1).</span>

<span class="sd">    **3. &#39;pearson&#39;** This is an only-slightly-more-complicated rule</span>
<span class="sd">    based on Pearson&#39;s chi-squared rule (as `explained</span>
<span class="sd">    &lt;https://web.archive.org/web/20210222093249/https://www-cdf.fnal.gov/physics/statistics/notes/pois_eb.txt&gt;`_ by</span>
<span class="sd">    the CDF working group). It also has the nice feature that if your</span>
<span class="sd">    theory curve touches an endpoint of the interval, then your data</span>
<span class="sd">    point is indeed one sigma away. The interval is</span>

<span class="sd">    .. math::</span>

<span class="sd">        CI = (n+0.5-\sqrt{n+0.25}, n+0.5+\sqrt{n+0.25})</span>

<span class="sd">    **4. &#39;sherpagehrels&#39;** This rule is used by default in the fitting</span>
<span class="sd">    package &#39;sherpa&#39;. The `documentation</span>
<span class="sd">    &lt;https://cxc.harvard.edu/sherpa4.4/statistics/#chigehrels&gt;`_ claims</span>
<span class="sd">    it is based on a numerical approximation published in `Gehrels</span>
<span class="sd">    (1986) &lt;https://ui.adsabs.harvard.edu/abs/1986ApJ...303..336G&gt;`_ but it</span>
<span class="sd">    does not actually appear there.  It is symmetrical, and while the</span>
<span class="sd">    upper limits are within about 1% of those given by</span>
<span class="sd">    &#39;frequentist-confidence&#39;, the lower limits can be badly wrong. The</span>
<span class="sd">    interval is</span>

<span class="sd">    .. math::</span>

<span class="sd">        CI = (n-1-\sqrt{n+0.75}, n+1+\sqrt{n+0.75})</span>

<span class="sd">    **5. &#39;frequentist-confidence&#39;** These are frequentist central</span>
<span class="sd">    confidence intervals:</span>

<span class="sd">    .. math::</span>

<span class="sd">        CI = (0.5 F_{\chi^2}^{-1}(\alpha;2n),</span>
<span class="sd">              0.5 F_{\chi^2}^{-1}(1-\alpha;2(n+1)))</span>

<span class="sd">    where :math:`F_{\chi^2}^{-1}` is the quantile of the chi-square</span>
<span class="sd">    distribution with the indicated number of degrees of freedom and</span>
<span class="sd">    :math:`\alpha` is the one-tailed probability of the normal</span>
<span class="sd">    distribution (at the point given by the parameter &#39;sigma&#39;). See</span>
<span class="sd">    `Maxwell (2011)</span>
<span class="sd">    &lt;https://ui.adsabs.harvard.edu/abs/2011arXiv1102.0822M&gt;`_ for further</span>
<span class="sd">    details.</span>

<span class="sd">    **6. &#39;kraft-burrows-nousek&#39;** This is a Bayesian approach which allows</span>
<span class="sd">    for the presence of a known background :math:`B` in the source signal</span>
<span class="sd">    :math:`N`.</span>
<span class="sd">    For a given confidence level :math:`CL` the confidence interval</span>
<span class="sd">    :math:`[S_\mathrm{min}, S_\mathrm{max}]` is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">       CL = \int^{S_\mathrm{max}}_{S_\mathrm{min}} f_{N,B}(S)dS</span>

<span class="sd">    where the function :math:`f_{N,B}` is:</span>

<span class="sd">    .. math::</span>

<span class="sd">       f_{N,B}(S) = C \frac{e^{-(S+B)}(S+B)^N}{N!}</span>

<span class="sd">    and the normalization constant :math:`C`:</span>

<span class="sd">    .. math::</span>

<span class="sd">       C = \left[ \int_0^\infty \frac{e^{-(S+B)}(S+B)^N}{N!} dS \right] ^{-1}</span>
<span class="sd">       = \left( \sum^N_{n=0} \frac{e^{-B}B^n}{n!}  \right)^{-1}</span>

<span class="sd">    See `Kraft, Burrows, and Nousek (1991)</span>
<span class="sd">    &lt;https://ui.adsabs.harvard.edu/abs/1991ApJ...374..344K&gt;`_ for further</span>
<span class="sd">    details.</span>

<span class="sd">    These formulas implement a positive, uniform prior.</span>
<span class="sd">    `Kraft, Burrows, and Nousek (1991)</span>
<span class="sd">    &lt;https://ui.adsabs.harvard.edu/abs/1991ApJ...374..344K&gt;`_ discuss this</span>
<span class="sd">    choice in more detail and show that the problem is relatively</span>
<span class="sd">    insensitive to the choice of prior.</span>

<span class="sd">    This function has an optional dependency: Either `Scipy</span>
<span class="sd">    &lt;https://www.scipy.org/&gt;`_ or `mpmath &lt;http://mpmath.org/&gt;`_  need</span>
<span class="sd">    to be available (Scipy works only for N &lt; 100).</span>
<span class="sd">    This code is very intense numerically, which makes it much slower than</span>
<span class="sd">    the other methods, in particular for large count numbers (above 1000</span>
<span class="sd">    even with ``mpmath``). Fortunately, some of the other methods or a</span>
<span class="sd">    Gaussian approximation usually work well in this regime.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(np.arange(10), interval=&#39;root-n&#39;).T</span>
<span class="sd">    array([[  0.        ,   0.        ],</span>
<span class="sd">           [  0.        ,   2.        ],</span>
<span class="sd">           [  0.58578644,   3.41421356],</span>
<span class="sd">           [  1.26794919,   4.73205081],</span>
<span class="sd">           [  2.        ,   6.        ],</span>
<span class="sd">           [  2.76393202,   7.23606798],</span>
<span class="sd">           [  3.55051026,   8.44948974],</span>
<span class="sd">           [  4.35424869,   9.64575131],</span>
<span class="sd">           [  5.17157288,  10.82842712],</span>
<span class="sd">           [  6.        ,  12.        ]])</span>

<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(np.arange(10), interval=&#39;root-n-0&#39;).T</span>
<span class="sd">    array([[  0.        ,   1.        ],</span>
<span class="sd">           [  0.        ,   2.        ],</span>
<span class="sd">           [  0.58578644,   3.41421356],</span>
<span class="sd">           [  1.26794919,   4.73205081],</span>
<span class="sd">           [  2.        ,   6.        ],</span>
<span class="sd">           [  2.76393202,   7.23606798],</span>
<span class="sd">           [  3.55051026,   8.44948974],</span>
<span class="sd">           [  4.35424869,   9.64575131],</span>
<span class="sd">           [  5.17157288,  10.82842712],</span>
<span class="sd">           [  6.        ,  12.        ]])</span>

<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(np.arange(10), interval=&#39;pearson&#39;).T</span>
<span class="sd">    array([[  0.        ,   1.        ],</span>
<span class="sd">           [  0.38196601,   2.61803399],</span>
<span class="sd">           [  1.        ,   4.        ],</span>
<span class="sd">           [  1.69722436,   5.30277564],</span>
<span class="sd">           [  2.43844719,   6.56155281],</span>
<span class="sd">           [  3.20871215,   7.79128785],</span>
<span class="sd">           [  4.        ,   9.        ],</span>
<span class="sd">           [  4.8074176 ,  10.1925824 ],</span>
<span class="sd">           [  5.62771868,  11.37228132],</span>
<span class="sd">           [  6.45861873,  12.54138127]])</span>

<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(</span>
<span class="sd">    ...     np.arange(10), interval=&#39;frequentist-confidence&#39;).T</span>
<span class="sd">    array([[  0.        ,   1.84102165],</span>
<span class="sd">           [  0.17275378,   3.29952656],</span>
<span class="sd">           [  0.70818544,   4.63785962],</span>
<span class="sd">           [  1.36729531,   5.91818583],</span>
<span class="sd">           [  2.08566081,   7.16275317],</span>
<span class="sd">           [  2.84030886,   8.38247265],</span>
<span class="sd">           [  3.62006862,   9.58364155],</span>
<span class="sd">           [  4.41852954,  10.77028072],</span>
<span class="sd">           [  5.23161394,  11.94514152],</span>
<span class="sd">           [  6.05653896,  13.11020414]])</span>

<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(</span>
<span class="sd">    ...     7, interval=&#39;frequentist-confidence&#39;).T</span>
<span class="sd">    array([  4.41852954,  10.77028072])</span>

<span class="sd">    &gt;&gt;&gt; poisson_conf_interval(</span>
<span class="sd">    ...     10, background=1.5, confidence_level=0.95,</span>
<span class="sd">    ...     interval=&#39;kraft-burrows-nousek&#39;).T  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[ 3.47894005, 16.113329533]])</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;root-n&#39;</span><span class="p">:</span>
        <span class="n">_check_poisson_conf_inputs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                  <span class="n">n</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;root-n-0&#39;</span><span class="p">:</span>
        <span class="n">_check_poisson_conf_inputs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                  <span class="n">n</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">conf_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conf_interval</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;pearson&#39;</span><span class="p">:</span>
        <span class="n">_check_poisson_conf_inputs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.25</span><span class="p">),</span>
                                  <span class="n">n</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.25</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;sherpagehrels&#39;</span><span class="p">:</span>
        <span class="n">_check_poisson_conf_inputs</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.75</span><span class="p">),</span>
                                  <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mf">0.75</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;frequentist-confidence&#39;</span><span class="p">:</span>
        <span class="n">_check_poisson_conf_inputs</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">scipy.stats</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span>
                                  <span class="mf">0.5</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">conf_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conf_interval</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="s1">&#39;kraft-burrows-nousek&#39;</span><span class="p">:</span>
        <span class="c1"># Deprecation warning in Python 3.9 when N is float, so we force int,</span>
        <span class="c1"># see https://github.com/astropy/astropy/issues/10832</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Number of counts must be integer.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Number of counts must be integer.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">confidence_level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Set confidence_level for method </span><span class="si">{}</span><span class="s1">. (sigma is &#39;</span>
                             <span class="s1">&#39;ignored.)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interval</span><span class="p">))</span>
        <span class="n">confidence_level</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">confidence_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">confidence_level</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">confidence_level</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;confidence_level must be a number between 0 and 1.&#39;</span><span class="p">)</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">background</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">background</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Background must be &gt;= 0.&#39;</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_kraft_burrows_nousek</span><span class="p">,</span>
                                     <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">n</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">confidence_level</span><span class="p">)</span>
        <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">conf_interval</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid method for Poisson confidence intervals: </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conf_interval</span></div>


<div class="viewcode-block" id="median_absolute_deviation"><a class="viewcode-back" href="../../../api/astropy.stats.median_absolute_deviation.html#astropy.stats.median_absolute_deviation">[docs]</a><span class="k">def</span> <span class="nf">median_absolute_deviation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the median absolute deviation (MAD).</span>

<span class="sd">    The MAD is defined as ``median(abs(a - median(a)))``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : None, int, or tuple of int, optional</span>
<span class="sd">        The axis or axes along which the MADs are computed.  The default</span>
<span class="sd">        (`None`) is to compute the MAD of the flattened array.</span>
<span class="sd">    func : callable, optional</span>
<span class="sd">        The function used to compute the median. Defaults to `numpy.ma.median`</span>
<span class="sd">        for masked arrays, otherwise to `numpy.median`.</span>
<span class="sd">    ignore_nan : bool</span>
<span class="sd">        Ignore NaN values (treat them as if they are not in the array) when</span>
<span class="sd">        computing the median.  This will use `numpy.ma.median` if ``axis`` is</span>
<span class="sd">        specified, or `numpy.nanmedian` if ``axis==None`` and numpy&#39;s version</span>
<span class="sd">        is &gt;1.10 because nanmedian is slightly faster in this case.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mad : float or `~numpy.ndarray`</span>
<span class="sd">        The median absolute deviation of the input array.  If ``axis``</span>
<span class="sd">        is `None` then a scalar will be returned, otherwise a</span>
<span class="sd">        `~numpy.ndarray` will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate random variates from a Gaussian distribution and return the</span>
<span class="sd">    median absolute deviation for that distribution::</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from astropy.stats import median_absolute_deviation</span>
<span class="sd">        &gt;&gt;&gt; rand = np.random.default_rng(12345)</span>
<span class="sd">        &gt;&gt;&gt; from numpy.random import randn</span>
<span class="sd">        &gt;&gt;&gt; mad = median_absolute_deviation(rand.standard_normal(1000))</span>
<span class="sd">        &gt;&gt;&gt; print(mad)    # doctest: +FLOAT_CMP</span>
<span class="sd">        0.6829504282771885</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mad_std</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if the array has a mask and if so use np.ma.median</span>
        <span class="c1"># See https://github.com/numpy/numpy/issues/7330 why using np.ma.median</span>
        <span class="c1"># for normal arrays should not be done (summary: np.ma.median always</span>
        <span class="c1"># returns an masked array even if the result should be scalar). (#4658)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">is_masked</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span>
            <span class="k">if</span> <span class="n">ignore_nan</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ignore_nan</span><span class="p">:</span>
            <span class="n">is_masked</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_masked</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>  <span class="c1"># drops units if result is NaN</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">is_masked</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># np.nanmedian has `keepdims`, which is a good option if we&#39;re not allowing</span>
    <span class="c1"># user-passed functions here</span>
    <span class="n">data_median</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="c1"># this conditional can be removed after this PR is merged:</span>
    <span class="c1"># https://github.com/astropy/astropy/issues/12165</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>
            <span class="ow">and</span> <span class="n">data_median</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_median</span><span class="p">)):</span>
        <span class="n">data_median</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">data_median</span><span class="p">)</span>

    <span class="c1"># broadcast the median array before subtraction</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data_median</span> <span class="o">=</span> <span class="n">_expand_dims</span><span class="p">(</span><span class="n">data_median</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>  <span class="c1"># NUMPY_LT_1_18</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_median</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># this conditional can be removed after this PR is merged:</span>
    <span class="c1"># https://github.com/astropy/astropy/issues/12165</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span>
            <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
        <span class="c1"># return scalar version</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_masked</span><span class="p">:</span>
        <span class="c1"># if the input array was not a masked array, we don&#39;t want to return a</span>
        <span class="c1"># masked array</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="mad_std"><a class="viewcode-back" href="../../../api/astropy.stats.mad_std.html#astropy.stats.mad_std">[docs]</a><span class="k">def</span> <span class="nf">mad_std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a robust standard deviation using the `median absolute</span>
<span class="sd">    deviation (MAD)</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Median_absolute_deviation&gt;`_.</span>

<span class="sd">    The standard deviation estimator is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \sigma \approx \frac{\textrm{MAD}}{\Phi^{-1}(3/4)}</span>
<span class="sd">            \approx 1.4826 \ \textrm{MAD}</span>

<span class="sd">    where :math:`\Phi^{-1}(P)` is the normal inverse cumulative</span>
<span class="sd">    distribution function evaluated at probability :math:`P = 3/4`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        Data array or object that can be converted to an array.</span>
<span class="sd">    axis : None, int, or tuple of int, optional</span>
<span class="sd">        The axis or axes along which the robust standard deviations are</span>
<span class="sd">        computed.  The default (`None`) is to compute the robust</span>
<span class="sd">        standard deviation of the flattened array.</span>
<span class="sd">    func : callable, optional</span>
<span class="sd">        The function used to compute the median. Defaults to `numpy.ma.median`</span>
<span class="sd">        for masked arrays, otherwise to `numpy.median`.</span>
<span class="sd">    ignore_nan : bool</span>
<span class="sd">        Ignore NaN values (treat them as if they are not in the array) when</span>
<span class="sd">        computing the median.  This will use `numpy.ma.median` if ``axis`` is</span>
<span class="sd">        specified, or `numpy.nanmedian` if ``axis=None`` and numpy&#39;s version is</span>
<span class="sd">        &gt;1.10 because nanmedian is slightly faster in this case.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mad_std : float or `~numpy.ndarray`</span>
<span class="sd">        The robust standard deviation of the input data.  If ``axis`` is</span>
<span class="sd">        `None` then a scalar will be returned, otherwise a</span>
<span class="sd">        `~numpy.ndarray` will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from astropy.stats import mad_std</span>
<span class="sd">    &gt;&gt;&gt; rand = np.random.default_rng(12345)</span>
<span class="sd">    &gt;&gt;&gt; madstd = mad_std(rand.normal(5, 2, (100, 100)))</span>
<span class="sd">    &gt;&gt;&gt; print(madstd)    # doctest: +FLOAT_CMP</span>
<span class="sd">    1.984147963351707</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    biweight_midvariance, biweight_midcovariance, median_absolute_deviation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NOTE: 1. / scipy.stats.norm.ppf(0.75) = 1.482602218505602</span>
    <span class="n">MAD</span> <span class="o">=</span> <span class="n">median_absolute_deviation</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">ignore_nan</span><span class="o">=</span><span class="n">ignore_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MAD</span> <span class="o">*</span> <span class="mf">1.482602218505602</span></div>


<div class="viewcode-block" id="signal_to_noise_oir_ccd"><a class="viewcode-back" href="../../../api/astropy.stats.signal_to_noise_oir_ccd.html#astropy.stats.signal_to_noise_oir_ccd">[docs]</a><span class="k">def</span> <span class="nf">signal_to_noise_oir_ccd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">source_eps</span><span class="p">,</span> <span class="n">sky_eps</span><span class="p">,</span> <span class="n">dark_eps</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">npix</span><span class="p">,</span>
                            <span class="n">gain</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the signal to noise ratio for source being observed in the</span>
<span class="sd">    optical/IR using a CCD.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : float or numpy.ndarray</span>
<span class="sd">        CCD integration time in seconds</span>
<span class="sd">    source_eps : float</span>
<span class="sd">        Number of electrons (photons) or DN per second in the aperture from the</span>
<span class="sd">        source. Note that this should already have been scaled by the filter</span>
<span class="sd">        transmission and the quantum efficiency of the CCD. If the input is in</span>
<span class="sd">        DN, then be sure to set the gain to the proper value for the CCD.</span>
<span class="sd">        If the input is in electrons per second, then keep the gain as its</span>
<span class="sd">        default of 1.0.</span>
<span class="sd">    sky_eps : float</span>
<span class="sd">        Number of electrons (photons) or DN per second per pixel from the sky</span>
<span class="sd">        background. Should already be scaled by filter transmission and QE.</span>
<span class="sd">        This must be in the same units as source_eps for the calculation to</span>
<span class="sd">        make sense.</span>
<span class="sd">    dark_eps : float</span>
<span class="sd">        Number of thermal electrons per second per pixel. If this is given in</span>
<span class="sd">        DN or ADU, then multiply by the gain to get the value in electrons.</span>
<span class="sd">    rd : float</span>
<span class="sd">        Read noise of the CCD in electrons. If this is given in</span>
<span class="sd">        DN or ADU, then multiply by the gain to get the value in electrons.</span>
<span class="sd">    npix : float</span>
<span class="sd">        Size of the aperture in pixels</span>
<span class="sd">    gain : float, optional</span>
<span class="sd">        Gain of the CCD. In units of electrons per DN.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SNR : float or numpy.ndarray</span>
<span class="sd">        Signal to noise ratio calculated from the inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">source_eps</span> <span class="o">*</span> <span class="n">gain</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">source_eps</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="n">npix</span> <span class="o">*</span>
                         <span class="p">(</span><span class="n">sky_eps</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">+</span> <span class="n">dark_eps</span><span class="p">))</span> <span class="o">+</span> <span class="n">npix</span> <span class="o">*</span> <span class="n">rd</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">noise</span></div>


<div class="viewcode-block" id="bootstrap"><a class="viewcode-back" href="../../../api/astropy.stats.bootstrap.html#astropy.stats.bootstrap">[docs]</a><span class="k">def</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bootnum</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bootfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs bootstrap resampling on numpy arrays.</span>

<span class="sd">    Bootstrap resampling is used to understand confidence intervals of sample</span>
<span class="sd">    estimates. This function returns versions of the dataset resampled with</span>
<span class="sd">    replacement (&quot;case bootstrapping&quot;). These can all be run through a function</span>
<span class="sd">    or statistic to produce a distribution of values which can then be used to</span>
<span class="sd">    find the confidence intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">        N-D array. The bootstrap resampling will be performed on the first</span>
<span class="sd">        index, so the first index should access the relevant information</span>
<span class="sd">        to be bootstrapped.</span>
<span class="sd">    bootnum : int, optional</span>
<span class="sd">        Number of bootstrap resamples</span>
<span class="sd">    samples : int, optional</span>
<span class="sd">        Number of samples in each resample. The default `None` sets samples to</span>
<span class="sd">        the number of datapoints</span>
<span class="sd">    bootfunc : function, optional</span>
<span class="sd">        Function to reduce the resampled data. Each bootstrap resample will</span>
<span class="sd">        be put through this function and the results returned. If `None`, the</span>
<span class="sd">        bootstrapped data will be returned</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boot : ndarray</span>

<span class="sd">        If bootfunc is None, then each row is a bootstrap resample of the data.</span>
<span class="sd">        If bootfunc is specified, then the columns will correspond to the</span>
<span class="sd">        outputs of bootfunc.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Obtain a twice resampled array:</span>

<span class="sd">    &gt;&gt;&gt; from astropy.stats import bootstrap</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from astropy.utils import NumpyRNGContext</span>
<span class="sd">    &gt;&gt;&gt; bootarr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])</span>
<span class="sd">    &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">    ...     bootresult = bootstrap(bootarr, 2)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; bootresult  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[6., 9., 0., 6., 1., 1., 2., 8., 7., 0.],</span>
<span class="sd">           [3., 5., 6., 3., 5., 3., 5., 8., 8., 0.]])</span>
<span class="sd">    &gt;&gt;&gt; bootresult.shape</span>
<span class="sd">    (2, 10)</span>

<span class="sd">    Obtain a statistic on the array</span>

<span class="sd">    &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">    ...     bootresult = bootstrap(bootarr, 2, bootfunc=np.mean)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; bootresult  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([4. , 4.6])</span>

<span class="sd">    Obtain a statistic with two outputs on the array</span>

<span class="sd">    &gt;&gt;&gt; test_statistic = lambda x: (np.sum(x), np.mean(x))</span>
<span class="sd">    &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">    ...     bootresult = bootstrap(bootarr, 3, bootfunc=test_statistic)</span>
<span class="sd">    &gt;&gt;&gt; bootresult  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([[40. ,  4. ],</span>
<span class="sd">           [46. ,  4.6],</span>
<span class="sd">           [35. ,  3.5]])</span>
<span class="sd">    &gt;&gt;&gt; bootresult.shape</span>
<span class="sd">    (3, 2)</span>

<span class="sd">    Obtain a statistic with two outputs on the array, keeping only the first</span>
<span class="sd">    output</span>

<span class="sd">    &gt;&gt;&gt; bootfunc = lambda x:test_statistic(x)[0]</span>
<span class="sd">    &gt;&gt;&gt; with NumpyRNGContext(1):</span>
<span class="sd">    ...     bootresult = bootstrap(bootarr, 3, bootfunc=bootfunc)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; bootresult  # doctest: +FLOAT_CMP</span>
<span class="sd">    array([40., 46., 35.])</span>
<span class="sd">    &gt;&gt;&gt; bootresult.shape</span>
<span class="sd">    (3,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># make sure the input is sane</span>
    <span class="k">if</span> <span class="n">samples</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">bootnum</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;neither &#39;samples&#39; nor &#39;bootnum&#39; can be less than 1.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bootfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resultdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bootnum</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="n">samples</span><span class="p">,)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># test number of outputs from bootfunc, avoid single outputs which are</span>
        <span class="c1"># array-like</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">resultdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bootnum</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bootfunc</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">resultdims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bootnum</span><span class="p">,)</span>

    <span class="c1"># create empty boot array</span>
    <span class="n">boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">resultdims</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
        <span class="n">bootarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bootfunc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">boot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">bootarr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">boot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bootfunc</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">bootarr</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">boot</span></div>


<span class="k">def</span> <span class="nf">_scipy_kraft_burrows_nousek</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CL</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Upper limit on a poisson count rate</span>

<span class="sd">    The implementation is based on Kraft, Burrows and Nousek</span>
<span class="sd">    `ApJ 374, 344 (1991) &lt;https://ui.adsabs.harvard.edu/abs/1991ApJ...374..344K&gt;`_.</span>
<span class="sd">    The XMM-Newton upper limit server uses the same formalism.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int or np.int32/np.int64</span>
<span class="sd">        Total observed count number</span>
<span class="sd">    B : float or np.float32/np.float64</span>
<span class="sd">        Background count rate (assumed to be known with negligible error</span>
<span class="sd">        from a large background area).</span>
<span class="sd">    CL : float or np.float32/np.float64</span>
<span class="sd">       Confidence level (number between 0 and 1)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : source count limit</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Requires :mod:`~scipy`. This implementation will cause Overflow Errors for</span>
<span class="sd">    about N &gt; 100 (the exact limit depends on details of how scipy was</span>
<span class="sd">    compiled). See `~astropy.stats.mpmath_poisson_upper_limit` for an</span>
<span class="sd">    implementation that is slower, but can deal with arbitrarily high numbers</span>
<span class="sd">    since it is based on the `mpmath &lt;http://mpmath.org/&gt;`_ library.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">brentq</span>
    <span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
    <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>

    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>

    <span class="k">def</span> <span class="nf">eqn8</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

    <span class="c1"># The parameters of eqn8 do not vary between calls so we can calculate the</span>
    <span class="c1"># result once and reuse it. The same is True for the factorial of N.</span>
    <span class="c1"># eqn7 is called hundred times so &quot;caching&quot; these values yields a</span>
    <span class="c1"># significant speedup (factor 10).</span>
    <span class="n">eqn8_res</span> <span class="o">=</span> <span class="n">eqn8</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">factorial_N</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">eqn7</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="n">SpB</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="n">B</span>
        <span class="k">return</span> <span class="n">eqn8_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">SpB</span><span class="p">)</span> <span class="o">*</span> <span class="n">SpB</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="n">factorial_N</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eqn9_left</span><span class="p">(</span><span class="n">S_min</span><span class="p">,</span> <span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="n">eqn7</span><span class="p">,</span> <span class="n">S_min</span><span class="p">,</span> <span class="n">S_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">limit</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_s_min</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Kraft, Burrows and Nousek suggest to integrate from N-B in both</span>
<span class="sd">        directions at once, so that S_min and S_max move similarly (see</span>
<span class="sd">        the article for details). Here, this is implemented differently:</span>
<span class="sd">        Treat S_max as the optimization parameters in func and then</span>
<span class="sd">        calculate the matching s_min that has has eqn7(S_max) =</span>
<span class="sd">        eqn7(S_min) here.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">y_S_max</span> <span class="o">=</span> <span class="n">eqn7</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eqn7</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">y_S_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">eqn7</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">y_S_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">s_min</span> <span class="o">=</span> <span class="n">find_s_min</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">eqn9_left</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">CL</span>

    <span class="n">S_max</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">S_min</span> <span class="o">=</span> <span class="n">find_s_min</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S_min</span><span class="p">,</span> <span class="n">S_max</span>


<span class="k">def</span> <span class="nf">_mpmath_kraft_burrows_nousek</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CL</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Upper limit on a poisson count rate</span>

<span class="sd">    The implementation is based on Kraft, Burrows and Nousek in</span>
<span class="sd">    `ApJ 374, 344 (1991) &lt;https://ui.adsabs.harvard.edu/abs/1991ApJ...374..344K&gt;`_.</span>
<span class="sd">    The XMM-Newton upper limit server used the same formalism.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int or np.int32/np.int64</span>
<span class="sd">        Total observed count number</span>
<span class="sd">    B : float or np.float32/np.float64</span>
<span class="sd">        Background count rate (assumed to be known with negligible error</span>
<span class="sd">        from a large background area).</span>
<span class="sd">    CL : float or np.float32/np.float64</span>
<span class="sd">       Confidence level (number between 0 and 1)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : source count limit</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Requires the `mpmath &lt;http://mpmath.org/&gt;`_ library.  See</span>
<span class="sd">    `~astropy.stats.scipy_poisson_upper_limit` for an implementation</span>
<span class="sd">    that is based on scipy and evaluates faster, but runs only to about</span>
<span class="sd">    N = 100.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">mpmath</span> <span class="kn">import</span> <span class="n">mpf</span><span class="p">,</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">findroot</span><span class="p">,</span> <span class="n">fsum</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">quad</span>

    <span class="c1"># We convert these values to float. Because for some reason,</span>
    <span class="c1"># mpmath.mpf cannot convert from numpy.int64</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">mpf</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">mpf</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="n">CL</span> <span class="o">=</span> <span class="n">mpf</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">CL</span><span class="p">))</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-4</span>

    <span class="k">def</span> <span class="nf">eqn8</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="n">sumterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">power</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">fsum</span><span class="p">(</span><span class="n">sumterms</span><span class="p">))</span>

    <span class="n">eqn8_res</span> <span class="o">=</span> <span class="n">eqn8</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">factorial_N</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eqn7</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="n">SpB</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="n">B</span>
        <span class="k">return</span> <span class="n">eqn8_res</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">SpB</span><span class="p">)</span> <span class="o">*</span> <span class="n">SpB</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="n">factorial_N</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eqn9_left</span><span class="p">(</span><span class="n">S_min</span><span class="p">,</span> <span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">eqn7NB</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">eqn7</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">quad</span><span class="p">(</span><span class="n">eqn7NB</span><span class="p">,</span> <span class="p">[</span><span class="n">S_min</span><span class="p">,</span> <span class="n">S_max</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">find_s_min</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Kraft, Burrows and Nousek suggest to integrate from N-B in both</span>
<span class="sd">        directions at once, so that S_min and S_max move similarly (see</span>
<span class="sd">        the article for details). Here, this is implemented differently:</span>
<span class="sd">        Treat S_max as the optimization parameters in func and then</span>
<span class="sd">        calculate the matching s_min that has has eqn7(S_max) =</span>
<span class="sd">        eqn7(S_min) here.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">y_S_max</span> <span class="o">=</span> <span class="n">eqn7</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="c1"># If B &gt; N, then N-B, the &quot;most probable&quot; values is &lt; 0</span>
        <span class="c1"># and thus s_min is certainly 0.</span>
        <span class="c1"># Note: For small N, s_max is also close to 0 and root finding</span>
        <span class="c1"># might find the wrong root, thus it is important to handle this</span>
        <span class="c1"># case here and return the analytical answer (s_min = 0).</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">eqn7</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">y_S_max</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">eqn7ysmax</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">eqn7</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">-</span> <span class="n">y_S_max</span>
            <span class="k">return</span> <span class="n">findroot</span><span class="p">(</span><span class="n">eqn7ysmax</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="p">],</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;ridder&#39;</span><span class="p">,</span>
                            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">s_min</span> <span class="o">=</span> <span class="n">find_s_min</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">eqn9_left</span><span class="p">(</span><span class="n">s_min</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">CL</span>

    <span class="c1"># Several numerical problems were found prevent the solvers from finding</span>
    <span class="c1"># the roots unless the starting values are very close to the final values.</span>
    <span class="c1"># Thus, this primitive, time-wasting, brute-force stepping here to get</span>
    <span class="c1"># an interval that can be fed into the ridder solver.</span>
    <span class="n">s_max_guess</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">B</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">func</span><span class="p">(</span><span class="n">s_max_guess</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s_max_guess</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">S_max</span> <span class="o">=</span> <span class="n">findroot</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">[</span><span class="n">s_max_guess</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s_max_guess</span><span class="p">],</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;ridder&#39;</span><span class="p">,</span>
                     <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
    <span class="n">S_min</span> <span class="o">=</span> <span class="n">find_s_min</span><span class="p">(</span><span class="n">S_max</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">S_min</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">S_max</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_kraft_burrows_nousek</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CL</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Upper limit on a poisson count rate</span>

<span class="sd">    The implementation is based on Kraft, Burrows and Nousek in</span>
<span class="sd">    `ApJ 374, 344 (1991) &lt;https://ui.adsabs.harvard.edu/abs/1991ApJ...374..344K&gt;`_.</span>
<span class="sd">    The XMM-Newton upper limit server used the same formalism.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int or np.int32/np.int64</span>
<span class="sd">        Total observed count number</span>
<span class="sd">    B : float or np.float32/np.float64</span>
<span class="sd">        Background count rate (assumed to be known with negligible error</span>
<span class="sd">        from a large background area).</span>
<span class="sd">    CL : float or np.float32/np.float64</span>
<span class="sd">       Confidence level (number between 0 and 1)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : source count limit</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This functions has an optional dependency: Either :mod:`scipy` or `mpmath</span>
<span class="sd">    &lt;http://mpmath.org/&gt;`_  need to be available. (Scipy only works for</span>
<span class="sd">    N &lt; 100).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">astropy.utils.compat.optional_deps</span> <span class="kn">import</span> <span class="n">HAS_SCIPY</span><span class="p">,</span> <span class="n">HAS_MPMATH</span>

    <span class="k">if</span> <span class="n">HAS_SCIPY</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_scipy_kraft_burrows_nousek</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CL</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_MPMATH</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need mpmath package for input numbers this &#39;</span>
                                 <span class="s1">&#39;large.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">HAS_MPMATH</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_mpmath_kraft_burrows_nousek</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">CL</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;Either scipy or mpmath are required.&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="kuiper_false_positive_probability"><a class="viewcode-back" href="../../../api/astropy.stats.kuiper_false_positive_probability.html#astropy.stats.kuiper_false_positive_probability">[docs]</a><span class="k">def</span> <span class="nf">kuiper_false_positive_probability</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the false positive probability for the Kuiper statistic.</span>

<span class="sd">    Uses the set of four formulas described in Paltani 2004; they report</span>
<span class="sd">    the resulting function never underestimates the false positive</span>
<span class="sd">    probability but can be a bit high in the N=40..50 range.</span>
<span class="sd">    (They quote a factor 1.5 at the 1e-7 level.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    D : float</span>
<span class="sd">        The Kuiper test score.</span>
<span class="sd">    N : float</span>
<span class="sd">        The effective sample size.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fpp : float</span>
<span class="sd">        The probability of a score this large arising from the null hypothesis.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Eq 7 of Paltani 2004 appears to incorrectly quote the original formula</span>
<span class="sd">    (Stephens 1965). This function implements the original formula, as it</span>
<span class="sd">    produces a result closer to Monte Carlo simulations.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Paltani, S., &quot;Searching for periods in X-ray observations using</span>
<span class="sd">           Kuiper&#39;s test. Application to the ROSAT PSPC archive&quot;,</span>
<span class="sd">           Astronomy and Astrophysics, v.240, p.789-790, 2004.</span>

<span class="sd">    .. [2] Stephens, M. A., &quot;The goodness-of-fit statistic VN: distribution</span>
<span class="sd">           and significance points&quot;, Biometrika, v.52, p.309, 1965.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">comb</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1"># Retained for backwards compatibility with older versions of scipy</span>
        <span class="c1"># (factorial appears to have moved here in 0.14)</span>
        <span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">comb</span>

    <span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="mf">2.</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have 0&lt;=D&lt;=2 by definition of the Kuiper test&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="mf">3.</span> <span class="o">/</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">D</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">D</span> <span class="o">-</span> <span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">k</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span> <span class="o">-</span> <span class="n">r</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">**</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">b</span><span class="p">))</span>
                    <span class="o">/</span> <span class="n">N</span><span class="o">**</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">))</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">D</span> <span class="o">&gt;</span> <span class="mf">0.5</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">D</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># NOTE: the upper limit of this sum is taken from Stephens 1965</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">t</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">Tt</span> <span class="o">=</span> <span class="n">y</span><span class="o">**</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">N</span>
                           <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
                           <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
                           <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">term1</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">term2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">D</span> <span class="o">-</span> <span class="n">t</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># term1 is formally finite, but is approximated by numpy as np.inf for</span>
        <span class="c1"># large values, so we set them to zero manually when they would be</span>
        <span class="c1"># multiplied by zero anyway</span>
        <span class="n">term1</span><span class="p">[(</span><span class="n">term1</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">term2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">final_term</span> <span class="o">=</span> <span class="n">Tt</span> <span class="o">*</span> <span class="n">term1</span> <span class="o">*</span> <span class="n">term2</span>
        <span class="k">return</span> <span class="n">final_term</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="c1"># When m*z&gt;18.82 (sqrt(-log(finfo(double))/2)), exp(-2m**2z**2)</span>
        <span class="c1"># underflows.  Cutting off just before avoids triggering a (pointless)</span>
        <span class="c1"># underflow warning if `under=&quot;warn&quot;`.</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">18.82</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">ms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">ms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ms</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S1</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">D</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">S2</span></div>


<div class="viewcode-block" id="kuiper"><a class="viewcode-back" href="../../../api/astropy.stats.kuiper.html#astropy.stats.kuiper">[docs]</a><span class="k">def</span> <span class="nf">kuiper</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cdf</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Compute the Kuiper statistic.</span>

<span class="sd">    Use the Kuiper statistic version of the Kolmogorov-Smirnov test to</span>
<span class="sd">    find the probability that a sample like ``data`` was drawn from the</span>
<span class="sd">    distribution whose CDF is given as ``cdf``.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This will not work correctly for distributions that are actually</span>
<span class="sd">        discrete (Poisson, for example).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        The data values.</span>
<span class="sd">    cdf : callable</span>
<span class="sd">        A callable to evaluate the CDF of the distribution being tested</span>
<span class="sd">        against. Will be called with a vector of all values at once.</span>
<span class="sd">        The default is a uniform distribution.</span>
<span class="sd">    args : list-like, optional</span>
<span class="sd">        Additional arguments to be supplied to cdf.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : float</span>
<span class="sd">        The raw statistic.</span>
<span class="sd">    fpp : float</span>
<span class="sd">        The probability of a D this large arising with a sample drawn from</span>
<span class="sd">        the distribution whose CDF is cdf.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Kuiper statistic resembles the Kolmogorov-Smirnov test in that</span>
<span class="sd">    it is nonparametric and invariant under reparameterizations of the data.</span>
<span class="sd">    The Kuiper statistic, in addition, is equally sensitive throughout</span>
<span class="sd">    the domain, and it is also invariant under cyclic permutations (making</span>
<span class="sd">    it particularly appropriate for analyzing circular data).</span>

<span class="sd">    Returns (D, fpp), where D is the Kuiper D number and fpp is the</span>
<span class="sd">    probability that a value as large as D would occur if data was</span>
<span class="sd">    drawn from cdf.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The fpp is calculated only approximately, and it can be</span>
<span class="sd">        as much as 1.5 times the true value.</span>

<span class="sd">    Stephens 1970 claims this is more effective than the KS at detecting</span>
<span class="sd">    changes in the variance of a distribution; the KS is (he claims) more</span>
<span class="sd">    sensitive at detecting changes in the mean.</span>

<span class="sd">    If cdf was obtained from data by fitting, then fpp is not correct and</span>
<span class="sd">    it will be necessary to do Monte Carlo simulations to interpret D.</span>
<span class="sd">    D should normally be independent of the shape of CDF.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Stephens, M. A., &quot;Use of the Kolmogorov-Smirnov, Cramer-Von Mises</span>
<span class="sd">           and Related Statistics Without Extensive Tables&quot;, Journal of the</span>
<span class="sd">           Royal Statistical Society. Series B (Methodological), Vol. 32,</span>
<span class="sd">           No. 1. (1970), pp. 115-122.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">cdfv</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cdfv</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span>
         <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">cdfv</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">kuiper_false_positive_probability</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span></div>


<div class="viewcode-block" id="kuiper_two"><a class="viewcode-back" href="../../../api/astropy.stats.kuiper_two.html#astropy.stats.kuiper_two">[docs]</a><span class="k">def</span> <span class="nf">kuiper_two</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the Kuiper statistic to compare two samples.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data1 : array-like</span>
<span class="sd">        The first set of data values.</span>
<span class="sd">    data2 : array-like</span>
<span class="sd">        The second set of data values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    D : float</span>
<span class="sd">        The raw test statistic.</span>
<span class="sd">    fpp : float</span>
<span class="sd">        The probability of obtaining two samples this different from</span>
<span class="sd">        the same distribution.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The fpp is quite approximate, especially for small samples.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>
    <span class="n">n1</span><span class="p">,</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n2</span><span class="p">,</span> <span class="o">=</span> <span class="n">data2</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">common_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([],</span> <span class="p">[</span><span class="n">data1</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">data2</span><span class="o">.</span><span class="n">dtype</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">common_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">common_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kuiper_two only accepts real inputs&#39;</span><span class="p">)</span>
    <span class="c1"># nans, if any, are at the end after sorting.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;kuiper_two only accepts non-nan inputs&#39;</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">_stats</span><span class="o">.</span><span class="n">ks_2samp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">common_type</span><span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">common_type</span><span class="p">))</span>
    <span class="n">Ne</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">D</span><span class="p">,</span> <span class="n">kuiper_false_positive_probability</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Ne</span><span class="p">)</span></div>


<div class="viewcode-block" id="fold_intervals"><a class="viewcode-back" href="../../../api/astropy.stats.fold_intervals.html#astropy.stats.fold_intervals">[docs]</a><span class="k">def</span> <span class="nf">fold_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fold the weighted intervals to the interval (0,1).</span>

<span class="sd">    Convert a list of intervals (ai, bi, wi) to a list of non-overlapping</span>
<span class="sd">    intervals covering (0,1). Each output interval has a weight equal</span>
<span class="sd">    to the sum of the wis of all the intervals that include it. All intervals</span>
<span class="sd">    are interpreted modulo 1, and weights are accumulated counting</span>
<span class="sd">    multiplicity. This is appropriate, for example, if you have one or more</span>
<span class="sd">    blocks of observation and you want to determine how much observation</span>
<span class="sd">    time was spent on different parts of a system&#39;s orbit (the blocks</span>
<span class="sd">    should be converted to units of the orbital period first).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intervals : list of (3,) tuple</span>
<span class="sd">        For each tuple (ai,bi,wi); ai and bi are the limits of the interval,</span>
<span class="sd">        and wi is the weight to apply to the interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    breaks : (N,) array of float</span>
<span class="sd">        The endpoints of a set of intervals covering [0,1]; breaks[0]=0 and</span>
<span class="sd">        breaks[-1] = 1</span>
<span class="sd">    weights : (N-1,) array of float</span>
<span class="sd">        The ith element is the sum of number of times the interval</span>
<span class="sd">        breaks[i],breaks[i+1] is included in each interval times the weight</span>
<span class="sd">        associated with that interval.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">breaks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="n">tot</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">wt</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">breaks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="o">-</span><span class="n">wt</span><span class="p">))</span>
        <span class="n">fb</span> <span class="o">=</span> <span class="n">b</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">breaks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fb</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">wt</span><span class="p">))</span>

    <span class="n">breaks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">breaks</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">breaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span>
    <span class="n">breaks_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">breaks</span><span class="p">)])</span>
    <span class="n">totals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">totals</span> <span class="o">+=</span> <span class="n">tot</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">wt</span><span class="p">)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">totals</span><span class="p">[</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span><span class="n">breaks_map</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">wt</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">breaks</span><span class="p">),</span> <span class="n">totals</span></div>


<div class="viewcode-block" id="cdf_from_intervals"><a class="viewcode-back" href="../../../api/astropy.stats.cdf_from_intervals.html#astropy.stats.cdf_from_intervals">[docs]</a><span class="k">def</span> <span class="nf">cdf_from_intervals</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">totals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct a callable piecewise-linear CDF from a pair of arrays.</span>

<span class="sd">    Take a pair of arrays in the format returned by fold_intervals and</span>
<span class="sd">    make a callable cumulative distribution function on the interval</span>
<span class="sd">    (0,1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    breaks : (N,) array of float</span>
<span class="sd">        The boundaries of successive intervals.</span>
<span class="sd">    totals : (N-1,) array of float</span>
<span class="sd">        The weight for each interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : callable</span>
<span class="sd">        A cumulative distribution function corresponding to the</span>
<span class="sd">        piecewise-constant probability distribution given by breaks, weights</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">breaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Intervals must be restricted to [0,1]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">breaks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breaks must be strictly increasing&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">totals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Total weights in each subinterval must be nonnegative&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">totals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one interval must have positive exposure&quot;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">breaks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">totals</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
    <span class="n">c</span> <span class="o">/=</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="interval_overlap_length"><a class="viewcode-back" href="../../../api/astropy.stats.interval_overlap_length.html#astropy.stats.interval_overlap_length">[docs]</a><span class="k">def</span> <span class="nf">interval_overlap_length</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the length of overlap of two intervals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i1, i2 : (float, float)</span>
<span class="sd">        The two intervals, (interval 1, interval 2).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    l : float</span>
<span class="sd">        The length of the overlap between the two intervals.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">i1</span>
    <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">i2</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span> <span class="o">-</span> <span class="n">c</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span> <span class="o">-</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="histogram_intervals"><a class="viewcode-back" href="../../../api/astropy.stats.histogram_intervals.html#astropy.stats.histogram_intervals">[docs]</a><span class="k">def</span> <span class="nf">histogram_intervals</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">breaks</span><span class="p">,</span> <span class="n">totals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Histogram of a piecewise-constant weight function.</span>

<span class="sd">    This function takes a piecewise-constant weight function and</span>
<span class="sd">    computes the average weight in each histogram bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of bins</span>
<span class="sd">    breaks : (N,) array of float</span>
<span class="sd">        Endpoints of the intervals in the PDF</span>
<span class="sd">    totals : (N-1,) array of float</span>
<span class="sd">        Probability densities in each bin</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    h : array of float</span>
<span class="sd">        The average weight for each bin</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">totals</span><span class="p">)):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">breaks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ol</span> <span class="o">=</span> <span class="n">interval_overlap_length</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span>
                                          <span class="nb">float</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">),</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ol</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">totals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>

    <span class="k">return</span> <span class="n">h</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 20112022, The Astropy Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.4. &nbsp;
    Last built 09 May 2022. <br/>
  </p>
</footer>
  </body>
</html>