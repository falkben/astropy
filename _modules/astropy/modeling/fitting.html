


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.modeling.fitting &#8212; Astropy v5.2.dev104+gcdd6a1f81.d20220509</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
  <meta name="robots" content="noindex, nofollow">
  
  
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v5.2.dev104+gcdd6a1f81.d20220509</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.modeling.fitting</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements classes (called Fitters) which combine optimization</span>
<span class="sd">algorithms (typically from `scipy.optimize`) with statistic functions to perform</span>
<span class="sd">fitting. Fitters are implemented as callable classes. In addition to the data</span>
<span class="sd">to fit, the ``__call__`` method takes an instance of</span>
<span class="sd">`~astropy.modeling.core.FittableModel` as input, and returns a copy of the</span>
<span class="sd">model with its parameters determined by the optimizer.</span>

<span class="sd">Optimization algorithms, called &quot;optimizers&quot; are implemented in</span>
<span class="sd">`~astropy.modeling.optimizers` and statistic functions are in</span>
<span class="sd">`~astropy.modeling.statistic`. The goal is to provide an easy to extend</span>
<span class="sd">framework and allow users to easily create new fitters by combining statistics</span>
<span class="sd">with optimizers.</span>

<span class="sd">There are two exceptions to the above scheme.</span>
<span class="sd">`~astropy.modeling.fitting.LinearLSQFitter` uses Numpy&#39;s `~numpy.linalg.lstsq`</span>
<span class="sd">function.  `~astropy.modeling.fitting.LevMarLSQFitter` uses</span>
<span class="sd">`~scipy.optimize.leastsq` which combines optimization and statistic in one</span>
<span class="sd">implementation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable=invalid-name</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">importlib.metadata</span> <span class="kn">import</span> <span class="n">entry_points</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>

<span class="kn">from</span> <span class="nn">.optimizers</span> <span class="kn">import</span> <span class="n">DEFAULT_ACC</span><span class="p">,</span> <span class="n">DEFAULT_EPS</span><span class="p">,</span> <span class="n">DEFAULT_MAXITER</span><span class="p">,</span> <span class="n">SLSQP</span><span class="p">,</span> <span class="n">Simplex</span>
<span class="kn">from</span> <span class="nn">.spline</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># noqa: F401</span>
    <span class="n">SplineExactKnotsFitter</span><span class="p">,</span> <span class="n">SplineInterpolateFitter</span><span class="p">,</span> <span class="n">SplineSmoothingFitter</span><span class="p">,</span> <span class="n">SplineSplrepFitter</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.statistic</span> <span class="kn">import</span> <span class="n">leastsquare</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">_combine_equivalency_dict</span><span class="p">,</span> <span class="n">poly_map_domain</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LinearLSQFitter&#39;</span><span class="p">,</span> <span class="s1">&#39;LevMarLSQFitter&#39;</span><span class="p">,</span> <span class="s1">&#39;TRFLSQFitter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DogBoxLSQFitter&#39;</span><span class="p">,</span> <span class="s1">&#39;LMLSQFitter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FittingWithOutlierRemoval&#39;</span><span class="p">,</span> <span class="s1">&#39;SLSQPLSQFitter&#39;</span><span class="p">,</span> <span class="s1">&#39;SimplexLSQFitter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;JointFitter&#39;</span><span class="p">,</span> <span class="s1">&#39;Fitter&#39;</span><span class="p">,</span> <span class="s1">&#39;ModelLinearityError&#39;</span><span class="p">,</span> <span class="s2">&quot;ModelsError&quot;</span><span class="p">]</span>


<span class="c1"># Statistic functions implemented in `astropy.modeling.statistic.py</span>
<span class="n">STATISTICS</span> <span class="o">=</span> <span class="p">[</span><span class="n">leastsquare</span><span class="p">]</span>

<span class="c1"># Optimizers implemented in `astropy.modeling.optimizers.py</span>
<span class="n">OPTIMIZERS</span> <span class="o">=</span> <span class="p">[</span><span class="n">Simplex</span><span class="p">,</span> <span class="n">SLSQP</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">NonFiniteValueError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Error raised when attempting to a non-finite value</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Covariance</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class for covariance matrix calculated by fitter. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_matrix</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">cov_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>

    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="p">,</span> <span class="n">round_val</span><span class="p">):</span>
        <span class="c1"># Print and label lower triangle of covariance matrix</span>
        <span class="c1"># Print rows for params up to `max_lines`, round floats to &#39;round_val&#39;</span>
        <span class="n">longest_name</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="n">ret_str</span> <span class="o">=</span> <span class="s1">&#39;parameter variances / covariances </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">fstring</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;&quot;</span><span class="si">:</span><span class="s1"> &lt;</span><span class="si">{</span><span class="n">longest_name</span><span class="si">}}</span><span class="s1">| </span><span class="se">{{</span><span class="s1">0</span><span class="se">}}\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_matrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_lines</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ret_str</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fstring</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="n">param</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">row</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">round_val</span><span class="p">))[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_str</span> <span class="o">+=</span> <span class="s1">&#39;...&#39;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ret_str</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">max_lines</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">round_val</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="c1"># index covariance matrix by parameter names or indices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Covariance must be indexed by two values.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
            <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Covariance can be indexed by two parameter names or integer indices.&#39;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_matrix</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">StandardDeviations</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Class for fitting uncertainties.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_matrix</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_stds</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_stds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_matrix</span><span class="p">):</span>
        <span class="c1"># sometimes scipy lstsq returns a non-sensical negative vals in the</span>
        <span class="c1"># diagonals of the cov_x it computes.</span>
        <span class="n">stds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">stds</span>

    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_lines</span><span class="p">,</span> <span class="n">round_val</span><span class="p">):</span>
        <span class="n">longest_name</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="n">ret_str</span> <span class="o">=</span> <span class="s1">&#39;standard deviations</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_lines</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ret_str</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="si">}{</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">longest_name</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">))</span><span class="si">}</span><span class="s2">| &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">std</span><span class="p">,</span> <span class="n">round_val</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_str</span> <span class="o">+=</span> <span class="s1">&#39;...&#39;</span>
        <span class="k">return</span><span class="p">(</span><span class="n">ret_str</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">max_lines</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">round_val</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">param</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Standard deviation can be indexed by parameter name or integer.&#39;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>


<div class="viewcode-block" id="ModelsError"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.ModelsError.html#astropy.modeling.fitting.ModelsError">[docs]</a><span class="k">class</span> <span class="nc">ModelsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for model exceptions&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="ModelLinearityError"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.ModelLinearityError.html#astropy.modeling.fitting.ModelLinearityError">[docs]</a><span class="k">class</span> <span class="nc">ModelLinearityError</span><span class="p">(</span><span class="n">ModelsError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Raised when a non-linear model is passed to a linear fitter.&quot;&quot;&quot;</span></div>


<span class="k">class</span> <span class="nc">UnsupportedConstraintError</span><span class="p">(</span><span class="n">ModelsError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised when a fitter does not support a type of constraint.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_FitterMeta</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Currently just provides a registry for all Fitter classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">registry</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isabstract</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="n">mcls</span><span class="o">.</span><span class="n">registry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span>


<span class="k">def</span> <span class="nf">fitter_unit_support</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a decorator that can be used to add support for dealing with</span>
<span class="sd">    quantities to any __call__ method on a fitter which may not support</span>
<span class="sd">    quantities itself. This is done by temporarily removing units from all</span>
<span class="sd">    parameters then adding them back once the fitting has completed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;equivalencies&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">data_has_units</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="ow">or</span>
                          <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="ow">or</span>
                          <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">))</span>

        <span class="n">model_has_units</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_has_units</span>

        <span class="k">if</span> <span class="n">data_has_units</span> <span class="ow">or</span> <span class="n">model_has_units</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">_supports_unit_fitting</span><span class="p">:</span>

                <span class="c1"># We now combine any instance-level input equivalencies with user</span>
                <span class="c1"># specified ones at call-time.</span>

                <span class="n">input_units_equivalencies</span> <span class="o">=</span> <span class="n">_combine_equivalency_dict</span><span class="p">(</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">equivalencies</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">input_units_equivalencies</span><span class="p">)</span>

                <span class="c1"># If input_units is defined, we transform the input data into those</span>
                <span class="c1"># expected by the model. We hard-code the input names &#39;x&#39;, and &#39;y&#39;</span>
                <span class="c1"># here since FittableModel instances have input names (&#39;x&#39;,) or</span>
                <span class="c1"># (&#39;x&#39;, &#39;y&#39;)</span>

                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">input_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">input_units</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                 <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">input_units</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                 <span class="n">equivalencies</span><span class="o">=</span><span class="n">input_units_equivalencies</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                <span class="c1"># Create a dictionary mapping the real model inputs and outputs</span>
                <span class="c1"># names to the data. This remapping of names must be done here, after</span>
                <span class="c1"># the input data is converted to the correct units.</span>
                <span class="n">rename_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">x</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">z</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">y</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">y</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># We now strip away the units from the parameters, taking care to</span>
                <span class="c1"># first convert any parameters to the units that correspond to the</span>
                <span class="c1"># input units (to make sure that initial guesses on the parameters)</span>
                <span class="c1"># are in the right unit system</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">without_units_for_data</span><span class="p">(</span><span class="o">**</span><span class="n">rename_data</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="s1">&#39;_left_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">rename_data</span><span class="p">[</span><span class="s1">&#39;_right_kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># We strip away the units from the input itself</span>
                <span class="n">add_back_units</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">add_back_units</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">add_back_units</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ydata</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                        <span class="n">add_back_units</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">zdata</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">zdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="c1"># We run the fitting</span>
                <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">model_new</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">model_new</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">zdata</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># And finally we add back units to the parameters</span>
                <span class="k">if</span> <span class="n">add_back_units</span><span class="p">:</span>
                    <span class="n">model_new</span> <span class="o">=</span> <span class="n">model_new</span><span class="o">.</span><span class="n">with_units_from_data</span><span class="p">(</span><span class="o">**</span><span class="n">rename_data</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">model_new</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This model does not support being &quot;</span>
                                          <span class="s2">&quot;fit to data with units.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="Fitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.Fitter.html#astropy.modeling.fitting.Fitter">[docs]</a><span class="k">class</span> <span class="nc">Fitter</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_FitterMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all fitters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    optimizer : callable</span>
<span class="sd">        A callable implementing an optimization algorithm</span>
<span class="sd">    statistic : callable</span>
<span class="sd">        Statistic function</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">supported_constraints</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">statistic</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">optimizer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected an optimizer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">statistic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a statistic function.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">optimizer</span><span class="p">):</span>
            <span class="c1"># a callable class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span> <span class="o">=</span> <span class="n">optimizer</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">optimizer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span> <span class="o">=</span> <span class="n">optimizer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected optimizer to be a callable class or a function.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">statistic</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stat_method</span> <span class="o">=</span> <span class="n">statistic</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stat_method</span> <span class="o">=</span> <span class="n">statistic</span>

<div class="viewcode-block" id="Fitter.objective_function"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.Fitter.html#astropy.modeling.fitting.Fitter.objective_function">[docs]</a>    <span class="k">def</span> <span class="nf">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to minimize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fps : list</span>
<span class="sd">            parameters returned by the fitter</span>
<span class="sd">        args : list</span>
<span class="sd">            [model, [other_args], [input coordinates]]</span>
<span class="sd">            other_args may include weights or any other quantities specific for</span>
<span class="sd">            a statistic</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The list of arguments (args) is set in the `__call__` method.</span>
<span class="sd">        Fitters may overwrite this method, e.g. when statistic functions</span>
<span class="sd">        require other arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fps</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_method</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_fitting_uncertainties</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When available, calculate and sets the parameter covariance matrix</span>
<span class="sd">        (model.cov_matrix) and standard deviations (model.stds).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Fitter.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.Fitter.html#astropy.modeling.fitting.Fitter.__call__">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs the actual fitting and modifies the parameter list</span>
<span class="sd">        of a model.</span>
<span class="sd">        Fitter subclasses should implement this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclasses should implement this method.&quot;</span><span class="p">)</span></div></div>


<span class="c1"># TODO: I have ongoing branch elsewhere that&#39;s refactoring this module so that</span>
<span class="c1"># all the fitter classes in here are Fitter subclasses.  In the meantime we</span>
<span class="c1"># need to specify that _FitterMeta is its metaclass.</span>
<div class="viewcode-block" id="LinearLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.LinearLSQFitter.html#astropy.modeling.fitting.LinearLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">LinearLSQFitter</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_FitterMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class performing a linear least square fitting.</span>
<span class="sd">    Uses `numpy.linalg.lstsq` to do the fitting.</span>
<span class="sd">    Given a model and data, fits the model to the data and changes the</span>
<span class="sd">    model&#39;s parameters. Keeps a dictionary of auxiliary fitting information.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that currently LinearLSQFitter does not support compound models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">supported_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fixed&#39;</span><span class="p">]</span>
    <span class="n">supports_masked_input</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;residuals&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;rank&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;singular_values&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="kc">None</span>
                         <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_uncertainties</span> <span class="o">=</span> <span class="n">calc_uncertainties</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_invertible</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if inverse of matrix can be obtained.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_add_fitting_uncertainties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">n_coeff</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">resids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and parameter covariance matrix and standard deviations</span>
<span class="sd">        and set `cov_matrix` and `stds` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_dot_x_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">masked</span> <span class="o">=</span> <span class="kc">False</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span>

        <span class="c1"># check if invertible. if not, can&#39;t calc covariance.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_invertible</span><span class="p">(</span><span class="n">x_dot_x_prime</span><span class="p">):</span>
            <span class="k">return</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">inv_x_dot_x_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">x_dot_x_prime</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># 1D models</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># single model</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">masked</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mask</span>
                <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="n">RSS</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">-</span><span class="n">n_coeff</span><span class="p">))</span> <span class="o">*</span> <span class="n">resids</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># model sets</span>
                <span class="n">RSS</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># collect sum residuals squared for each model in set</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">masked</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                    <span class="n">eval_y</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">eval_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">eval_y</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">RSS</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">-</span><span class="n">n_coeff</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">eval_y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># 2D model</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">masked</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Calculation of fitting uncertainties &#39;</span>
                                  <span class="s1">&#39;for 2D models with masked values not &#39;</span>
                                  <span class="s1">&#39;currently supported.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                                  <span class="n">AstropyUserWarning</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">xx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="c1"># len(xx) instead of xx.count. this will break if values are masked?</span>
                <span class="n">RSS</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span><span class="o">-</span><span class="n">n_coeff</span><span class="p">))</span> <span class="o">*</span> <span class="n">resids</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">RSS</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)):</span>
                    <span class="n">eval_z</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># need to figure out how to deal w/ masking here.</span>
                    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># model_set_axis passed when evaluating only refers to input shapes</span>
                        <span class="c1"># so output must be reshaped for model_set_axis=1.</span>
                        <span class="n">eval_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">eval_z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">eval_z</span> <span class="o">=</span> <span class="n">eval_z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">RSS</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">n_coeff</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">z</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">eval_z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)])</span>

        <span class="n">covs</span> <span class="o">=</span> <span class="p">[</span><span class="n">inv_x_dot_x_prime</span> <span class="o">*</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">RSS</span><span class="p">]</span>
        <span class="n">free_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">fixed</span> <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">covs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">covs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="n">StandardDeviations</span><span class="p">(</span><span class="n">covs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">free_param_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span><span class="o">.</span><span class="n">cov_matrix</span> <span class="o">=</span> <span class="p">[</span><span class="n">Covariance</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">cov</span> <span class="ow">in</span> <span class="n">covs</span><span class="p">]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="p">[</span><span class="n">StandardDeviations</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">free_param_names</span><span class="p">)</span> <span class="k">for</span> <span class="n">cov</span> <span class="ow">in</span> <span class="n">covs</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_deriv_with_constraints</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">param_indices</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">param_indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">param_indices</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_map_domain_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps domain into window for a polynomial model which has these</span>
<span class="sd">        attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;window&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">poly_map_domain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">window</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;x_domain&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">x_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">x_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;y_domain&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">y_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">y_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;x_window&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">x_window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">x_window</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;y_window&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">y_window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">y_window</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>

            <span class="n">xnew</span> <span class="o">=</span> <span class="n">poly_map_domain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">x_domain</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">x_window</span><span class="p">)</span>
            <span class="n">ynew</span> <span class="o">=</span> <span class="n">poly_map_domain</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">y_domain</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">y_window</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">ynew</span>

<div class="viewcode-block" id="LinearLSQFitter.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.LinearLSQFitter.html#astropy.modeling.fitting.LinearLSQFitter.__call__">[docs]</a>    <span class="nd">@fitter_unit_support</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data to this model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            model to fit to x, y, z</span>
<span class="sd">        x : array</span>
<span class="sd">            Input coordinates</span>
<span class="sd">        y : array-like</span>
<span class="sd">            Input coordinates</span>
<span class="sd">        z : array-like, optional</span>
<span class="sd">            Input coordinates.</span>
<span class="sd">            If the dependent (``y`` or ``z``) coordinate values are provided</span>
<span class="sd">            as a `numpy.ma.MaskedArray`, any masked points are ignored when</span>
<span class="sd">            fitting. Note that model set fitting is significantly slower when</span>
<span class="sd">            there are masked points (not just an empty mask), as the matrix</span>
<span class="sd">            equation has to be solved for each model separately when their</span>
<span class="sd">            coordinate grids differ.</span>
<span class="sd">        weights : array, optional</span>
<span class="sd">            Weights for fitting.</span>
<span class="sd">            For data with Gaussian uncertainties, the weights should be</span>
<span class="sd">            1/sigma.</span>
<span class="sd">        rcond :  float, optional</span>
<span class="sd">            Cut-off ratio for small singular values of ``a``.</span>
<span class="sd">            Singular values are set to zero if they are smaller than ``rcond``</span>
<span class="sd">            times the largest singular value of ``a``.</span>
<span class="sd">        equivalencies : list or None, optional, keyword-only</span>
<span class="sd">            List of *additional* equivalencies that are should be applied in</span>
<span class="sd">            case x, y and/or z have units. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_copy : `~astropy.modeling.FittableModel`</span>
<span class="sd">            a copy of the input model with parameters set by the fitter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">fittable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model must be a subclass of FittableModel&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModelLinearityError</span><span class="p">(</span><span class="s1">&#39;Model is not linear in parameters, &#39;</span>
                                      <span class="s1">&#39;linear fit methods should not be used.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s2">&quot;submodel_names&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model must be simple, not compound&quot;</span><span class="p">)</span>

        <span class="n">_validate_constraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supported_constraints</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="n">model_copy</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">fitparam_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected x, y and z for a 2 dimensional model.&quot;</span><span class="p">)</span>

        <span class="n">farg</span> <span class="o">=</span> <span class="n">_convert_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">n_models</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">),</span>
                              <span class="n">model_set_axis</span><span class="o">=</span><span class="n">model_copy</span><span class="o">.</span><span class="n">model_set_axis</span><span class="p">)</span>

        <span class="n">has_fixed</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">model_copy</span><span class="o">.</span><span class="n">fixed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># This is also done by _convert_inputs, but we need it here to allow</span>
        <span class="c1"># checking the array dimensionality before that gets called:</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">has_fixed</span><span class="p">:</span>

            <span class="c1"># The list of fixed params is the complement of those being fitted:</span>
            <span class="n">fixparam_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="o">.</span><span class="n">param_names</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fitparam_indices</span><span class="p">]</span>

            <span class="c1"># Construct matrix of user-fixed parameters that can be dotted with</span>
            <span class="c1"># the corresponding fit_deriv() terms, to evaluate corrections to</span>
            <span class="c1"># the dependent variable in order to fit only the remaining terms:</span>
            <span class="n">fixparams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span>
                                            <span class="n">model_copy</span><span class="o">.</span><span class="n">param_names</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">value</span>
                                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">fixparam_indices</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">farg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">farg</span>

            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If we have separate weights for each model, apply the same</span>
                <span class="c1"># conversion as for the data, otherwise check common weights</span>
                <span class="c1"># as if for a single model:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_convert_input</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span>
                    <span class="n">n_models</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">model_set_axis</span><span class="o">=</span><span class="n">model_copy</span><span class="o">.</span><span class="n">model_set_axis</span>
                <span class="p">)</span>

            <span class="c1"># map domain into window</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="s1">&#39;domain&#39;</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_domain_window</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_fixed</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deriv_with_constraints</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span>
                                                              <span class="n">fitparam_indices</span><span class="p">,</span>
                                                              <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">))</span>
                <span class="n">fixderivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deriv_with_constraints</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">fixparam_indices</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">model_copy</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">model_copy</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
            <span class="n">sum_of_implicit_terms</span> <span class="o">=</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">sum_of_implicit_terms</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">farg</span>

            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If we have separate weights for each model, apply the same</span>
                <span class="c1"># conversion as for the data, otherwise check common weights</span>
                <span class="c1"># as if for a single model:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">_convert_input</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span>
                    <span class="n">n_models</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">model_set_axis</span><span class="o">=</span><span class="n">model_copy</span><span class="o">.</span><span class="n">model_set_axis</span>
                <span class="p">)</span>

            <span class="c1"># map domain into window</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="s1">&#39;x_domain&#39;</span><span class="p">):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_domain_window</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">has_fixed</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deriv_with_constraints</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span>
                                                              <span class="n">fitparam_indices</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">))</span>
                <span class="n">fixderivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deriv_with_constraints</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span>
                                                         <span class="n">fixparam_indices</span><span class="p">,</span>
                                                         <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">model_copy</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">model_copy</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
            <span class="n">sum_of_implicit_terms</span> <span class="o">=</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">sum_of_implicit_terms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                <span class="c1"># Just to be explicit (rather than baking in False == 0):</span>
                <span class="n">model_axis</span> <span class="o">=</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">model_set_axis</span> <span class="ow">or</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># For higher-dimensional z, flatten all the axes except the</span>
                    <span class="c1"># dimension along which models are stacked and transpose so</span>
                    <span class="c1"># the model axis is *last* (I think this resolves Erik&#39;s</span>
                    <span class="c1"># pending generalization from 80a6f25a):</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">model_axis</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This &quot;else&quot; seems to handle the corner case where the</span>
                    <span class="c1"># user has already flattened x/y before attempting a 2D fit</span>
                    <span class="c1"># but z has a second axis for the model set. NB. This is</span>
                    <span class="c1"># ~5-10x faster than using rollaxis.</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">model_axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">z</span>

                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Same for weights</span>
                    <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Separate 2D weights for each model:</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">model_axis</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                        <span class="c1"># Separate, flattened weights for each model:</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">model_axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">weights</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Common weights for all the models:</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># If the derivative is defined along rows (as with non-linear models)</span>
        <span class="k">if</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Some models (eg. Polynomial1D) don&#39;t flatten multi-dimensional inputs</span>
        <span class="c1"># when constructing their Vandermonde matrix, which can lead to obscure</span>
        <span class="c1"># failures below. Ultimately, np.linalg.lstsq can&#39;t handle &gt;2D matrices,</span>
        <span class="c1"># so just raise a slightly more informative error when this happens:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> gives unsupported &gt;2D &quot;</span>
                             <span class="s2">&quot;derivative matrix for this x/y&quot;</span><span class="p">)</span>

        <span class="c1"># Subtract any terms fixed by the user from (a copy of) the RHS, in</span>
        <span class="c1"># order to fit the remaining terms correctly:</span>
        <span class="k">if</span> <span class="n">has_fixed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                <span class="n">fixderivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fixderivs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># as for lhs above</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">-</span> <span class="n">fixderivs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fixparams</span><span class="p">)</span>  <span class="c1"># evaluate user-fixed terms</span>

        <span class="c1"># Subtract any terms implicit in the model from the RHS, which, like</span>
        <span class="c1"># user-fixed terms, affect the dependent variable but are not fitted:</span>
        <span class="k">if</span> <span class="n">sum_of_implicit_terms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If we have a model set, the extra axis must be added to</span>
            <span class="c1"># sum_of_implicit_terms as its innermost dimension, to match the</span>
            <span class="c1"># dimensionality of rhs after _convert_input &quot;rolls&quot; it as needed</span>
            <span class="c1"># by np.linalg.lstsq. The vector then gets broadcast to the right</span>
            <span class="c1"># number of sets (columns). This assumes all the models share the</span>
            <span class="c1"># same input coordinates, as is currently the case.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sum_of_implicit_terms</span> <span class="o">=</span> <span class="n">sum_of_implicit_terms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">-</span> <span class="n">sum_of_implicit_terms</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="c1"># separate weights for multiple models case: broadcast</span>
                    <span class="c1"># lhs to have more dimension (for each model)</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">*</span> <span class="n">weights</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lhs</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                    <span class="c1"># Don&#39;t modify in-place in case rhs was the original</span>
                    <span class="c1"># dependent variable array</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs</span> <span class="o">*=</span> <span class="n">weights</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">*</span> <span class="n">weights</span>

        <span class="n">scl</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">*</span> <span class="n">lhs</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">lhs</span> <span class="o">/=</span> <span class="n">scl</span>

        <span class="n">masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">masked</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lhs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Found NaNs in the coefficient matrix, which &#39;</span>
                             <span class="s1">&#39;should not happen and would crash the lapack &#39;</span>
                             <span class="s1">&#39;routine. Maybe check that weights are not null.&#39;</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># need for calculating covarience</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">masked</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>

            <span class="c1"># Separate masks or weights for multiple models case: Numpy&#39;s</span>
            <span class="c1"># lstsq supports multiple dimensions only for rhs, so we need to</span>
            <span class="c1"># loop manually on the models. This may be fixed in the future</span>
            <span class="c1"># with https://github.com/numpy/numpy/pull/15777.</span>

            <span class="c1"># Initialize empty array of coefficients and populate it one model</span>
            <span class="c1"># at a time. The shape matches the number of coefficients from the</span>
            <span class="c1"># Vandermonde matrix and the number of models from the RHS:</span>
            <span class="n">lacoef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rhs</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># Arrange the lhs as a stack of 2D matrices that we can iterate</span>
            <span class="c1"># over to get the correctly-orientated lhs for each model:</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">lhs_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lhs_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Loop over the models and solve for each one. By this point, the</span>
            <span class="c1"># model set axis is the second of two. Transpose rather than using,</span>
            <span class="c1"># say, np.moveaxis(array, -1, 0), since it&#39;s slightly faster and</span>
            <span class="c1"># lstsq can&#39;t handle &gt;2D arrays anyway. This could perhaps be</span>
            <span class="c1"># optimized by collecting together models with identical masks</span>
            <span class="c1"># (eg. those with no rejected points) into one operation, though it</span>
            <span class="c1"># will still be relatively slow when calling lstsq repeatedly.</span>
            <span class="k">for</span> <span class="n">model_lhs</span><span class="p">,</span> <span class="n">model_rhs</span><span class="p">,</span> <span class="n">model_lacoef</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lhs_stack</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lacoef</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>

                <span class="c1"># Cull masked points on both sides of the matrix equation:</span>
                <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">model_rhs</span><span class="o">.</span><span class="n">mask</span> <span class="k">if</span> <span class="n">masked</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">model_lhs</span> <span class="o">=</span> <span class="n">model_lhs</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
                <span class="n">model_rhs</span> <span class="o">=</span> <span class="n">model_rhs</span><span class="p">[</span><span class="n">good</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">model_lhs</span>

                <span class="c1"># Solve for this model:</span>
                <span class="n">t_coef</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">model_lhs</span><span class="p">,</span>
                                                             <span class="n">model_rhs</span><span class="p">,</span> <span class="n">rcond</span><span class="p">)</span>
                <span class="n">model_lacoef</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">t_coef</span><span class="o">.</span><span class="n">T</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># If we&#39;re fitting one or more models over a common set of points,</span>
            <span class="c1"># we only have to solve a single matrix equation, which is an order</span>
            <span class="c1"># of magnitude faster than calling lstsq() once per model below:</span>

            <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">rhs</span><span class="o">.</span><span class="n">mask</span> <span class="k">if</span> <span class="n">masked</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># latter is a no-op</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>
            <span class="c1"># Solve for one or more models:</span>
            <span class="n">lacoef</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">sval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                                                         <span class="n">rhs</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">rcond</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;residuals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;singular_values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sval</span>

        <span class="n">lacoef</span> <span class="o">/=</span> <span class="n">scl</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">if</span> <span class="n">scl</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="k">else</span> <span class="n">scl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lacoef</span>

        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">lacoef</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="c1"># TODO: Only Polynomial models currently have an _order attribute;</span>
        <span class="c1"># maybe change this to read isinstance(model, PolynomialBase)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="s1">&#39;_order&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">has_fixed</span> <span class="ow">and</span>
                <span class="n">rank</span> <span class="o">!=</span> <span class="n">model_copy</span><span class="o">.</span><span class="n">_order</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The fit may be poorly conditioned</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>

        <span class="c1"># calculate and set covariance matrix and standard devs. on model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_uncertainties</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lacoef</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_fitting_uncertainties</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">scl</span><span class="p">,</span>
                                                <span class="nb">len</span><span class="p">(</span><span class="n">lacoef</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">resids</span><span class="p">)</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">model_copy</span></div></div>


<div class="viewcode-block" id="FittingWithOutlierRemoval"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.FittingWithOutlierRemoval.html#astropy.modeling.fitting.FittingWithOutlierRemoval">[docs]</a><span class="k">class</span> <span class="nc">FittingWithOutlierRemoval</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class combines an outlier removal technique with a fitting procedure.</span>
<span class="sd">    Basically, given a maximum number of iterations ``niter``, outliers are</span>
<span class="sd">    removed and fitting is performed for each iteration, until no new outliers</span>
<span class="sd">    are found or ``niter`` is reached.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fitter : `Fitter`</span>
<span class="sd">        An instance of any Astropy fitter, i.e., LinearLSQFitter,</span>
<span class="sd">        LevMarLSQFitter, SLSQPLSQFitter, SimplexLSQFitter, JointFitter. For</span>
<span class="sd">        model set fitting, this must understand masked input data (as</span>
<span class="sd">        indicated by the fitter class attribute ``supports_masked_input``).</span>
<span class="sd">    outlier_func : callable</span>
<span class="sd">        A function for outlier removal.</span>
<span class="sd">        If this accepts an ``axis`` parameter like the `numpy` functions, the</span>
<span class="sd">        appropriate value will be supplied automatically when fitting model</span>
<span class="sd">        sets (unless overridden in ``outlier_kwargs``), to find outliers for</span>
<span class="sd">        each model separately; otherwise, the same filtering must be performed</span>
<span class="sd">        in a loop over models, which is almost an order of magnitude slower.</span>
<span class="sd">    niter : int, optional</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    outlier_kwargs : dict, optional</span>
<span class="sd">        Keyword arguments for outlier_func.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info : dict</span>
<span class="sd">        The ``fit_info`` (if any) from the last iteration of the wrapped</span>
<span class="sd">        ``fitter`` during the most recent fit. An entry is also added with the</span>
<span class="sd">        keyword ``niter`` that records the actual number of fitting iterations</span>
<span class="sd">        performed (as opposed to the user-specified maximum).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitter</span><span class="p">,</span> <span class="n">outlier_func</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="o">**</span><span class="n">outlier_kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitter</span> <span class="o">=</span> <span class="n">fitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlier_func</span> <span class="o">=</span> <span class="n">outlier_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="n">niter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span> <span class="o">=</span> <span class="n">outlier_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;niter&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Outlier function: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Num. of iterations: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Outlier func. args.: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(fitter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;outlier_func: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; niter: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="si">}</span><span class="s2">, outlier_kwargs: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="FittingWithOutlierRemoval.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.FittingWithOutlierRemoval.html#astropy.modeling.fitting.FittingWithOutlierRemoval.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            An analytic model which will be fit to the provided data.</span>
<span class="sd">            This also contains the initial guess for an optimization</span>
<span class="sd">            algorithm.</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Input coordinates.</span>
<span class="sd">        y : array-like</span>
<span class="sd">            Data measurements (1D case) or input coordinates (2D case).</span>
<span class="sd">        z : array-like, optional</span>
<span class="sd">            Data measurements (2D case).</span>
<span class="sd">        weights : array-like, optional</span>
<span class="sd">            Weights to be passed to the fitter.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to be passed to the fitter.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fitted_model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            Fitted model after outlier removal.</span>
<span class="sd">        mask : `numpy.ndarray`</span>
<span class="sd">            Boolean mask array, identifying which points were used in the final</span>
<span class="sd">            fitting iteration (False) and which were found to be outliers or</span>
<span class="sd">            were masked in the input (True).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For single models, the data get filtered here at each iteration and</span>
        <span class="c1"># then passed to the fitter, which is the historical behavior and</span>
        <span class="c1"># works even for fitters that don&#39;t understand masked arrays. For model</span>
        <span class="c1"># sets, the fitter must be able to filter masked data internally,</span>
        <span class="c1"># because fitters require a single set of x/y coordinates whereas the</span>
        <span class="c1"># eliminated points can vary between models. To avoid this limitation,</span>
        <span class="c1"># we could fall back to looping over individual model fits, but it</span>
        <span class="c1"># would likely be fiddly and involve even more overhead (and the</span>
        <span class="c1"># non-linear fitters don&#39;t work with model sets anyway, as of writing).</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">,</span> <span class="s1">&#39;supports_masked_input&#39;</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="o">.</span><span class="n">supports_masked_input</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot fit model sets with masked &quot;</span>
                                 <span class="s2">&quot;values&quot;</span><span class="p">)</span>

            <span class="c1"># Fitters use their input model&#39;s model_set_axis to determine how</span>
            <span class="c1"># their input data are stacked:</span>
            <span class="n">model_set_axis</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_set_axis</span>
        <span class="c1"># Construct input coordinate tuples for fitters &amp; models that are</span>
        <span class="c1"># appropriate for the dimensionality being fitted:</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">z</span>

        <span class="c1"># For model sets, construct a numpy-standard &quot;axis&quot; tuple for the</span>
        <span class="c1"># outlier function, to treat each model separately (if supported):</span>
        <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model_set_axis</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>

            <span class="k">if</span> <span class="s1">&#39;axis&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span><span class="p">:</span>  <span class="c1"># allow user override</span>
                <span class="c1"># This also works for False (like model instantiation):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">model_set_axis</span>
                <span class="p">)</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Starting fit, prior to any iteration and masking:</span>
        <span class="n">fitted_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">filtered_weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="n">last_n_masked</span> <span class="o">=</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># (allow recording no. of iterations when 0)</span>

        <span class="c1"># Perform the iterative fitting:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># (Re-)evaluate the last model:</span>
            <span class="n">model_vals</span> <span class="o">=</span> <span class="n">fitted_model</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Determine the outliers:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">loop</span><span class="p">:</span>

                <span class="c1"># Pass axis parameter if outlier_func accepts it, otherwise</span>
                <span class="c1"># prepare for looping over models:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_func</span><span class="p">(</span>
                        <span class="n">filtered_data</span> <span class="o">-</span> <span class="n">model_vals</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span>
                    <span class="p">)</span>
                <span class="c1"># If this happens to catch an error with a parameter other</span>
                <span class="c1"># than axis, the next attempt will fail accordingly:</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">loop</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="c1"># Construct MaskedArray to hold filtered values:</span>
                        <span class="n">filtered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span>
                            <span class="n">filtered_data</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">model_vals</span><span class="p">),</span>
                            <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="c1"># Make sure the mask is an array, not just nomask:</span>
                        <span class="k">if</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
                            <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>

                        <span class="c1"># Get views transposed appropriately for iteration</span>
                        <span class="c1"># over the set (handling data &amp; mask separately due to</span>
                        <span class="c1"># NumPy issue #8506):</span>
                        <span class="n">data_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">mask_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                             <span class="n">model_set_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">loop</span><span class="p">:</span>
                <span class="n">model_vals_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">model_vals</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row_data</span><span class="p">,</span> <span class="n">row_mask</span><span class="p">,</span> <span class="n">row_mod_vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_T</span><span class="p">,</span> <span class="n">mask_T</span><span class="p">,</span>
                                                            <span class="n">model_vals_T</span><span class="p">):</span>
                    <span class="n">masked_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_func</span><span class="p">(</span>
                        <span class="n">row_data</span> <span class="o">-</span> <span class="n">row_mod_vals</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">outlier_kwargs</span>
                    <span class="p">)</span>
                    <span class="n">row_data</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">masked_residuals</span><span class="o">.</span><span class="n">data</span>
                    <span class="n">row_mask</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">masked_residuals</span><span class="o">.</span><span class="n">mask</span>

                <span class="c1"># Issue speed warning after the fact, so it only shows up when</span>
                <span class="c1"># the TypeError is genuinely due to the axis argument.</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;outlier_func did not accept axis argument; &#39;</span>
                              <span class="s1">&#39;reverted to slow loop over models.&#39;</span><span class="p">,</span>
                              <span class="n">AstropyUserWarning</span><span class="p">)</span>

            <span class="c1"># Recombine newly-masked residuals with model to get masked values:</span>
            <span class="n">filtered_data</span> <span class="o">+=</span> <span class="n">model_vals</span>

            <span class="c1"># Re-fit the data after filtering, passing masked/unmasked values</span>
            <span class="c1"># for single models / sets, respectively:</span>
            <span class="k">if</span> <span class="n">model_set_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">good</span> <span class="o">=</span> <span class="o">~</span><span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span>

                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filtered_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">good</span><span class="p">]</span>

                <span class="n">fitted_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">(</span><span class="n">fitted_model</span><span class="p">,</span>
                                           <span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">good</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">),</span>
                                           <span class="n">filtered_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">good</span><span class="p">],</span>
                                           <span class="n">weights</span><span class="o">=</span><span class="n">filtered_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fitted_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">(</span><span class="n">fitted_model</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">,</span>
                                           <span class="n">filtered_data</span><span class="p">,</span>
                                           <span class="n">weights</span><span class="o">=</span><span class="n">filtered_weights</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Stop iteration if the masked points are no longer changing (with</span>
            <span class="c1"># cumulative rejection we only need to compare how many there are):</span>
            <span class="n">this_n_masked</span> <span class="o">=</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># (minimal overhead)</span>
            <span class="k">if</span> <span class="n">this_n_masked</span> <span class="o">==</span> <span class="n">last_n_masked</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">last_n_masked</span> <span class="o">=</span> <span class="n">this_n_masked</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;niter&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitter</span><span class="p">,</span> <span class="s1">&#39;fit_info&#39;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="k">return</span> <span class="n">fitted_model</span><span class="p">,</span> <span class="n">filtered_data</span><span class="o">.</span><span class="n">mask</span></div></div>


<span class="k">class</span> <span class="nc">_NonLinearLSQFitter</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_FitterMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Non-Linear least-squares fitters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>
<span class="sd">    use_min_max_bounds : bool</span>
<span class="sd">        If the set parameter bounds for a model will be enforced each given</span>
<span class="sd">        parameter while fitting via a simple min/max condition.</span>
<span class="sd">        Default: True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">supported_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;tied&#39;</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The constraint types supported by this fitter type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_uncertainties</span> <span class="o">=</span> <span class="n">calc_uncertainties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_min_max_bounds</span> <span class="o">=</span> <span class="n">use_min_max_bounds</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to minimize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fps : list</span>
<span class="sd">            parameters returned by the fitter</span>
<span class="sd">        args : list</span>
<span class="sd">            [model, [weights], [input coordinates]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_min_max_bounds</span><span class="p">)</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">meas</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span> <span class="o">*</span> <span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">meas</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">NonFiniteValueError</span><span class="p">(</span><span class="s2">&quot;Objective function has encountered a non-finite value, &quot;</span>
                                      <span class="s2">&quot;this will cause the fit to fail!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_fitting_uncertainties</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">cov_matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set ``cov_matrix`` and ``stds`` attributes on model with parameter</span>
<span class="sd">        covariance matrix returned by ``optimize.leastsq``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">fixed</span> <span class="k">if</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>
                            <span class="ow">and</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)]</span>

        <span class="n">model</span><span class="o">.</span><span class="n">cov_matrix</span> <span class="o">=</span> <span class="n">Covariance</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">,</span> <span class="n">free_param_names</span><span class="p">)</span>
        <span class="n">model</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="n">StandardDeviations</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">,</span> <span class="n">free_param_names</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_wrap_deriv</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps the method calculating the Jacobian of the function to account</span>
<span class="sd">        for model constraints.</span>
<span class="sd">        `scipy.optimize.leastsq` expects the function derivative to have the</span>
<span class="sd">        above signature (parlist, (argtuple)). In order to accommodate model</span>
<span class="sd">        constraints, instead of using p directly, we set the parameter list in</span>
<span class="sd">        this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="c1"># update the parameters with the current values from the fitter</span>
            <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                    <span class="n">full_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">full</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">full_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">full</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">)])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                    <span class="n">full_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">full</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">full_deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">full</span>

            <span class="n">pars</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
            <span class="n">fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">par</span><span class="o">.</span><span class="n">fixed</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">]</span>
            <span class="n">tied</span> <span class="o">=</span> <span class="p">[</span><span class="n">par</span><span class="o">.</span><span class="n">tied</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">]</span>
            <span class="n">tied</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">par</span><span class="o">.</span><span class="n">tied</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">],</span>
                                 <span class="kc">True</span><span class="p">,</span> <span class="n">tied</span><span class="p">))</span>
            <span class="n">fix_and_tie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">tied</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">fix_and_tie</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                <span class="n">residues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">full_deriv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ind</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residues</span> <span class="o">=</span> <span class="n">full_deriv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)),</span>
                                         <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span>
                            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">weights</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">_compute_param_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">cov_x</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">,</span> <span class="n">farg</span><span class="p">):</span>
        <span class="c1"># now try to compute the true covariance matrix</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_values</span><span class="p">))</span> <span class="ow">and</span> <span class="n">cov_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sum_sqrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">(</span><span class="n">fitparams</span><span class="p">,</span> <span class="o">*</span><span class="n">farg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;param_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_x</span> <span class="o">*</span> <span class="n">sum_sqrs</span> <span class="o">/</span> <span class="n">dof</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;param_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_uncertainties</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;param_cov&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_fitting_uncertainties</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;param_cov&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_run_fitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">estimate_jacobian</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nd">@fitter_unit_support</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">maxiter</span><span class="o">=</span><span class="n">DEFAULT_MAXITER</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">DEFAULT_ACC</span><span class="p">,</span>
                 <span class="n">epsilon</span><span class="o">=</span><span class="n">DEFAULT_EPS</span><span class="p">,</span> <span class="n">estimate_jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data to this model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            model to fit to x, y, z</span>
<span class="sd">        x : array</span>
<span class="sd">           input coordinates</span>
<span class="sd">        y : array</span>
<span class="sd">           input coordinates</span>
<span class="sd">        z : array, optional</span>
<span class="sd">           input coordinates</span>
<span class="sd">        weights : array, optional</span>
<span class="sd">            Weights for fitting.</span>
<span class="sd">            For data with Gaussian uncertainties, the weights should be</span>
<span class="sd">            1/sigma.</span>
<span class="sd">        maxiter : int</span>
<span class="sd">            maximum number of iterations</span>
<span class="sd">        acc : float</span>
<span class="sd">            Relative error desired in the approximate solution</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            A suitable step length for the forward-difference</span>
<span class="sd">            approximation of the Jacobian (if model.fjac=None). If</span>
<span class="sd">            epsfcn is less than the machine precision, it is</span>
<span class="sd">            assumed that the relative errors in the functions are</span>
<span class="sd">            of the order of the machine precision.</span>
<span class="sd">        estimate_jacobian : bool</span>
<span class="sd">            If False (default) and if the model has a fit_deriv method,</span>
<span class="sd">            it will be used. Otherwise the Jacobian will be estimated.</span>
<span class="sd">            If True, the Jacobian will be estimated in any case.</span>
<span class="sd">        equivalencies : list or None, optional, keyword-only</span>
<span class="sd">            List of *additional* equivalencies that are should be applied in</span>
<span class="sd">            case x, y and/or z have units. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_copy : `~astropy.modeling.FittableModel`</span>
<span class="sd">            a copy of the input model with parameters set by the fitter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model_copy</span> <span class="o">=</span> <span class="n">_validate_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_constraints</span><span class="p">)</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">_convert_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">init_values</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">,</span> <span class="n">cov_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_fitter</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span>
                                                         <span class="n">maxiter</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">estimate_jacobian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_param_cov</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">cov_x</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">,</span> <span class="n">farg</span><span class="p">)</span>

        <span class="n">model</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">model_copy</span>


<div class="viewcode-block" id="LevMarLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.LevMarLSQFitter.html#astropy.modeling.fitting.LevMarLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">LevMarLSQFitter</span><span class="p">(</span><span class="n">_NonLinearLSQFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt algorithm and least squares statistic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info : dict</span>
<span class="sd">        The `scipy.optimize.leastsq` result for the most recent fit (see</span>
<span class="sd">        notes).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``fit_info`` dictionary contains the values returned by</span>
<span class="sd">    `scipy.optimize.leastsq` for the most recent fit, including the values from</span>
<span class="sd">    the ``infodict`` dictionary it returns. See the `scipy.optimize.leastsq`</span>
<span class="sd">    documentation for details on the meaning of these values. Note that the</span>
<span class="sd">    ``x`` return value is *not* included (as it is instead the parameter values</span>
<span class="sd">    of the returned model).</span>
<span class="sd">    Additionally, one additional element of ``fit_info`` is computed whenever a</span>
<span class="sd">    model is fit, with the key &#39;param_cov&#39;. The corresponding value is the</span>
<span class="sd">    covariance matrix of the parameters as a 2D numpy array.  The order of the</span>
<span class="sd">    matrix elements matches the order of the parameters in the fitted model</span>
<span class="sd">    (i.e., the same order as ``model.param_names``).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">calc_uncertainties</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nfev&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;fvec&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;fjac&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;ipvt&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;qtf&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;message&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;ierr&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;param_jac&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="s1">&#39;param_cov&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_run_fitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">estimate_jacobian</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">estimate_jacobian</span><span class="p">:</span>
            <span class="n">dfunc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_deriv</span>
        <span class="n">init_values</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">fitparams</span><span class="p">,</span> <span class="n">cov_x</span><span class="p">,</span> <span class="n">dinfo</span><span class="p">,</span> <span class="n">mess</span><span class="p">,</span> <span class="n">ierr</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">farg</span><span class="p">,</span> <span class="n">Dfun</span><span class="o">=</span><span class="n">dfunc</span><span class="p">,</span>
            <span class="n">col_deriv</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">epsfcn</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">xtol</span><span class="o">=</span><span class="n">acc</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dinfo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;cov_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="p">[</span><span class="s1">&#39;ierr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ierr</span>
        <span class="k">if</span> <span class="n">ierr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The fit may be unsuccessful; check &quot;</span>
                          <span class="s2">&quot;fit_info[&#39;message&#39;] for more information.&quot;</span><span class="p">,</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">,</span> <span class="n">cov_x</span></div>


<span class="k">class</span> <span class="nc">_NLLSQFitter</span><span class="p">(</span><span class="n">_NonLinearLSQFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper class for `scipy.optimize.least_squares` method, which provides:</span>
<span class="sd">        - Trust Region Reflective</span>
<span class="sd">        - dogbox</span>
<span class="sd">        - Levenberg-Marqueardt</span>
<span class="sd">    algorithms using the least squares statistic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>
<span class="sd">        trf :  Trust Region Reflective algorithm, particularly suitable</span>
<span class="sd">            for large sparse problems with bounds. Generally robust method.</span>
<span class="sd">        dogbox : dogleg algorithm with rectangular trust regions, typical</span>
<span class="sd">            use case is small problems with bounds. Not recommended for</span>
<span class="sd">            problems with rank-deficient Jacobian.</span>
<span class="sd">        lm : Levenberg-Marquardt algorithm as implemented in MINPACK.</span>
<span class="sd">            Doesnt handle bounds and sparse Jacobians. Usually the most</span>
<span class="sd">            efficient method for small unconstrained problems.</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>
<span class="sd">    use_min_max_bounds: bool</span>
<span class="sd">        If the set parameter bounds for a model will be enforced each given</span>
<span class="sd">        parameter while fitting via a simple min/max condition. A True setting</span>
<span class="sd">        will replicate how LevMarLSQFitter enforces bounds.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info :</span>
<span class="sd">        A `scipy.optimize.OptimizeResult` class which contains all of</span>
<span class="sd">        the most recent fit information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">calc_uncertainties</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_method</span> <span class="o">=</span> <span class="n">method</span>

    <span class="k">def</span> <span class="nf">_run_fitter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span> <span class="n">maxiter</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">estimate_jacobian</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
        <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svd</span>

        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">fit_deriv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">estimate_jacobian</span><span class="p">:</span>
            <span class="n">dfunc</span> <span class="o">=</span> <span class="s1">&#39;2-point&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_dfunc</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">col_fit_deriv</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrap_deriv</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_deriv</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

            <span class="n">dfunc</span> <span class="o">=</span> <span class="n">_dfunc</span>

        <span class="n">init_values</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Note, if use_min_max_bounds is True we are defaulting to enforcing bounds</span>
        <span class="c1"># using the old method employed by LevMarLSQFitter, this is different</span>
        <span class="c1"># from the method that optimize.least_squares employs to enforce bounds</span>
        <span class="c1"># thus we override the bounds being passed to optimize.least_squares so</span>
        <span class="c1"># that it will not enforce any bounding.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_min_max_bounds</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">farg</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">dfunc</span><span class="p">,</span>
            <span class="n">max_nfev</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">diff_step</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">epsilon</span><span class="p">),</span> <span class="n">xtol</span><span class="o">=</span><span class="n">acc</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_method</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
        <span class="p">)</span>

        <span class="c1"># Adapted from ~scipy.optimize.minpack, see:</span>
        <span class="c1"># https://github.com/scipy/scipy/blob/47bb6febaa10658c72962b9615d5d5aa2513fa3a/scipy/optimize/minpack.py#L795-L816</span>
        <span class="c1"># Do Moore-Penrose inverse discarding zero singular values.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">jac</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">jac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span>
        <span class="n">VT</span> <span class="o">=</span> <span class="n">VT</span><span class="p">[:</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">cov_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VT</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">VT</span><span class="p">)</span>

        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The fit may be unsuccessful; check: </span><span class="se">\n</span><span class="s2">&quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">init_values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cov_x</span>


<div class="viewcode-block" id="TRFLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.TRFLSQFitter.html#astropy.modeling.fitting.TRFLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">TRFLSQFitter</span><span class="p">(</span><span class="n">_NLLSQFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trust Region Reflective algorithm and least squares statistic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>
<span class="sd">    use_min_max_bounds: bool</span>
<span class="sd">        If the set parameter bounds for a model will be enforced each given</span>
<span class="sd">        parameter while fitting via a simple min/max condition. A True setting</span>
<span class="sd">        will replicate how LevMarLSQFitter enforces bounds.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info :</span>
<span class="sd">        A `scipy.optimize.OptimizeResult` class which contains all of</span>
<span class="sd">        the most recent fit information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;trf&#39;</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="p">)</span></div>


<div class="viewcode-block" id="DogBoxLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.DogBoxLSQFitter.html#astropy.modeling.fitting.DogBoxLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">DogBoxLSQFitter</span><span class="p">(</span><span class="n">_NLLSQFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DogBox algorithm and least squares statistic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>
<span class="sd">    use_min_max_bounds: bool</span>
<span class="sd">        If the set parameter bounds for a model will be enforced each given</span>
<span class="sd">        parameter while fitting via a simple min/max condition. A True setting</span>
<span class="sd">        will replicate how LevMarLSQFitter enforces bounds.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info :</span>
<span class="sd">        A `scipy.optimize.OptimizeResult` class which contains all of</span>
<span class="sd">        the most recent fit information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;dogbox&#39;</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="p">)</span></div>


<div class="viewcode-block" id="LMLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.LMLSQFitter.html#astropy.modeling.fitting.LMLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">LMLSQFitter</span><span class="p">(</span><span class="n">_NLLSQFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `scipy.optimize.least_squares` Levenberg-Marquardt algorithm and least squares statistic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    calc_uncertainties : bool</span>
<span class="sd">        If the covarience matrix should be computed and set in the fit_info.</span>
<span class="sd">        Default: False</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fit_info :</span>
<span class="sd">        A `scipy.optimize.OptimizeResult` class which contains all of</span>
<span class="sd">        the most recent fit information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;lm&#39;</span><span class="p">,</span> <span class="n">calc_uncertainties</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="SLSQPLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.SLSQPLSQFitter.html#astropy.modeling.fitting.SLSQPLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">SLSQPLSQFitter</span><span class="p">(</span><span class="n">Fitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sequential Least Squares Programming (SLSQP) optimization algorithm and</span>
<span class="sd">    least squares statistic.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ModelLinearityError</span>
<span class="sd">        A linear model is passed to a nonlinear fitter</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    See also the `~astropy.modeling.optimizers.SLSQP` optimizer.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">supported_constraints</span> <span class="o">=</span> <span class="n">SLSQP</span><span class="o">.</span><span class="n">supported_constraints</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">SLSQP</span><span class="p">,</span> <span class="n">statistic</span><span class="o">=</span><span class="n">leastsquare</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="SLSQPLSQFitter.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.SLSQPLSQFitter.html#astropy.modeling.fitting.SLSQPLSQFitter.__call__">[docs]</a>    <span class="nd">@fitter_unit_support</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data to this model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            model to fit to x, y, z</span>
<span class="sd">        x : array</span>
<span class="sd">            input coordinates</span>
<span class="sd">        y : array</span>
<span class="sd">            input coordinates</span>
<span class="sd">        z : array, optional</span>
<span class="sd">            input coordinates</span>
<span class="sd">        weights : array, optional</span>
<span class="sd">            Weights for fitting.</span>
<span class="sd">            For data with Gaussian uncertainties, the weights should be</span>
<span class="sd">            1/sigma.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            optional keyword arguments to be passed to the optimizer or the statistic</span>
<span class="sd">        verblevel : int</span>
<span class="sd">            0-silent</span>
<span class="sd">            1-print summary upon completion,</span>
<span class="sd">            2-print summary after each iteration</span>
<span class="sd">        maxiter : int</span>
<span class="sd">            maximum number of iterations</span>
<span class="sd">        epsilon : float</span>
<span class="sd">            the step size for finite-difference derivative estimates</span>
<span class="sd">        acc : float</span>
<span class="sd">            Requested accuracy</span>
<span class="sd">        equivalencies : list or None, optional, keyword-only</span>
<span class="sd">            List of *additional* equivalencies that are should be applied in</span>
<span class="sd">            case x, y and/or z have units. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_copy : `~astropy.modeling.FittableModel`</span>
<span class="sd">            a copy of the input model with parameters set by the fitter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model_copy</span> <span class="o">=</span> <span class="n">_validate_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span><span class="o">.</span><span class="n">supported_constraints</span><span class="p">)</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="n">_convert_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">farg</span>
        <span class="n">init_values</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span>
        <span class="n">fitparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">)</span>

        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">model_copy</span></div></div>


<div class="viewcode-block" id="SimplexLSQFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.SimplexLSQFitter.html#astropy.modeling.fitting.SimplexLSQFitter">[docs]</a><span class="k">class</span> <span class="nc">SimplexLSQFitter</span><span class="p">(</span><span class="n">Fitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplex algorithm and least squares statistic.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    `ModelLinearityError`</span>
<span class="sd">        A linear model is passed to a nonlinear fitter</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">supported_constraints</span> <span class="o">=</span> <span class="n">Simplex</span><span class="o">.</span><span class="n">supported_constraints</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">Simplex</span><span class="p">,</span> <span class="n">statistic</span><span class="o">=</span><span class="n">leastsquare</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="SimplexLSQFitter.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.SimplexLSQFitter.html#astropy.modeling.fitting.SimplexLSQFitter.__call__">[docs]</a>    <span class="nd">@fitter_unit_support</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data to this model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : `~astropy.modeling.FittableModel`</span>
<span class="sd">            model to fit to x, y, z</span>
<span class="sd">        x : array</span>
<span class="sd">            input coordinates</span>
<span class="sd">        y : array</span>
<span class="sd">            input coordinates</span>
<span class="sd">        z : array, optional</span>
<span class="sd">            input coordinates</span>
<span class="sd">        weights : array, optional</span>
<span class="sd">            Weights for fitting.</span>
<span class="sd">            For data with Gaussian uncertainties, the weights should be</span>
<span class="sd">            1/sigma.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            optional keyword arguments to be passed to the optimizer or the statistic</span>
<span class="sd">        maxiter : int</span>
<span class="sd">            maximum number of iterations</span>
<span class="sd">        acc : float</span>
<span class="sd">            Relative error in approximate solution</span>
<span class="sd">        equivalencies : list or None, optional, keyword-only</span>
<span class="sd">            List of *additional* equivalencies that are should be applied in</span>
<span class="sd">            case x, y and/or z have units. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_copy : `~astropy.modeling.FittableModel`</span>
<span class="sd">            a copy of the input model with parameters set by the fitter</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model_copy</span> <span class="o">=</span> <span class="n">_validate_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span><span class="o">.</span><span class="n">supported_constraints</span><span class="p">)</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="n">_convert_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">farg</span>

        <span class="n">init_values</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">)</span>

        <span class="n">fitparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">init_values</span><span class="p">,</span> <span class="n">farg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model_copy</span><span class="p">,</span> <span class="n">fitparams</span><span class="p">)</span>
        <span class="n">model_copy</span><span class="o">.</span><span class="n">sync_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">model_copy</span></div></div>


<div class="viewcode-block" id="JointFitter"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.JointFitter.html#astropy.modeling.fitting.JointFitter">[docs]</a><span class="k">class</span> <span class="nc">JointFitter</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_FitterMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit models which share a parameter.</span>
<span class="sd">    For example, fit two gaussians to two data sets but keep</span>
<span class="sd">    the FWHM the same.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    models : list</span>
<span class="sd">        a list of model instances</span>
<span class="sd">    jointparameters : list</span>
<span class="sd">        a list of joint parameters</span>
<span class="sd">    initvals : list</span>
<span class="sd">        a list of initial values</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">jointparameters</span><span class="p">,</span> <span class="n">initvals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initvals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">initvals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span> <span class="o">=</span> <span class="n">jointparameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verify_input</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_to_fit_params</span><span class="p">()</span>

        <span class="c1"># a list of model.n_inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modeldims</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">n_inputs</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">]</span>
        <span class="c1"># sum all model dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modeldims</span><span class="p">)</span>

<div class="viewcode-block" id="JointFitter.model_to_fit_params"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.JointFitter.html#astropy.modeling.fitting.JointFitter.model_to_fit_params">[docs]</a>    <span class="k">def</span> <span class="nf">model_to_fit_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fparams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fparams</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initvals</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">joint_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="p">[</span><span class="n">model</span><span class="p">]</span>
            <span class="n">param_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_param_metrics</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">joint_params</span><span class="p">:</span>
                <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">param_name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">params</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span>
            <span class="n">fparams</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fparams</span></div>

<div class="viewcode-block" id="JointFitter.objective_function"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.JointFitter.html#astropy.modeling.fitting.JointFitter.objective_function">[docs]</a>    <span class="k">def</span> <span class="nf">objective_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to minimize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fps : list</span>
<span class="sd">            the fitted parameters - result of an one iteration of the</span>
<span class="sd">            fitting algorithm</span>
<span class="sd">        args : dict</span>
<span class="sd">            tuple of measured and input coordinates</span>
<span class="sd">            args is always passed as a tuple from optimize.leastsq</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lstsqargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">fitted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fitparams</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="n">numjp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initvals</span><span class="p">)</span>
        <span class="c1"># make a separate list of the joint fitted parameters</span>
        <span class="n">jointfitparams</span> <span class="o">=</span> <span class="n">fitparams</span><span class="p">[:</span><span class="n">numjp</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">fitparams</span><span class="p">[:</span><span class="n">numjp</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="n">joint_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="p">[</span><span class="n">model</span><span class="p">]</span>
            <span class="n">margs</span> <span class="o">=</span> <span class="n">lstsqargs</span><span class="p">[:</span><span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">lstsqargs</span><span class="p">[:</span><span class="n">model</span><span class="o">.</span><span class="n">n_inputs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># separate each model separately fitted parameters</span>
            <span class="n">numfp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_parameters</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">joint_params</span><span class="p">)</span>
            <span class="n">mfparams</span> <span class="o">=</span> <span class="n">fitparams</span><span class="p">[:</span><span class="n">numfp</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">fitparams</span><span class="p">[:</span><span class="n">numfp</span><span class="p">]</span>
            <span class="c1"># recreate the model parameters</span>
            <span class="n">mparams</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">param_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_param_metrics</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">joint_params</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">joint_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                    <span class="c1"># should do this with slices in case the</span>
                    <span class="c1"># parameter is not a number</span>
                    <span class="n">mparams</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">jointfitparams</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">param_name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>
                    <span class="n">plen</span> <span class="o">=</span> <span class="n">slice_</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slice_</span><span class="o">.</span><span class="n">start</span>
                    <span class="n">mparams</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mfparams</span><span class="p">[:</span><span class="n">plen</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">mfparams</span><span class="p">[:</span><span class="n">plen</span><span class="p">]</span>
            <span class="n">modelfit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">margs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">mparams</span><span class="p">)</span>
            <span class="n">fitted</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">modelfit</span> <span class="o">-</span> <span class="n">margs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">fitted</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_verify_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected &gt;1 models, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span><span class="si">}</span><span class="s2"> is given&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;At least two parameters are expected, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> is given&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initvals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="si">}</span><span class="s2"> parameter(s) &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;provided but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initvals</span><span class="p">)</span><span class="si">}</span><span class="s2"> expected&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="JointFitter.__call__"><a class="viewcode-back" href="../../../api/astropy.modeling.fitting.JointFitter.html#astropy.modeling.fitting.JointFitter.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data to these models keeping some of the parameters common to the</span>
<span class="sd">        two models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modeldims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modeldims</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;coordinates in args but </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> provided&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitparams</span><span class="p">[:],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">fitparams</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

        <span class="n">fparams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitparams</span><span class="p">[:]</span>
        <span class="n">numjp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initvals</span><span class="p">)</span>
        <span class="c1"># make a separate list of the joint fitted parameters</span>
        <span class="n">jointfitparams</span> <span class="o">=</span> <span class="n">fparams</span><span class="p">[:</span><span class="n">numjp</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">fparams</span><span class="p">[:</span><span class="n">numjp</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
            <span class="c1"># extract each model&#39;s fitted parameters</span>
            <span class="n">joint_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jointparams</span><span class="p">[</span><span class="n">model</span><span class="p">]</span>
            <span class="n">numfp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">_parameters</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">joint_params</span><span class="p">)</span>
            <span class="n">mfparams</span> <span class="o">=</span> <span class="n">fparams</span><span class="p">[:</span><span class="n">numfp</span><span class="p">]</span>

            <span class="k">del</span> <span class="n">fparams</span><span class="p">[:</span><span class="n">numfp</span><span class="p">]</span>
            <span class="c1"># recreate the model parameters</span>
            <span class="n">mparams</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">param_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_param_metrics</span>
            <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">joint_params</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">joint_params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>
                    <span class="c1"># should do this with slices in case the parameter</span>
                    <span class="c1"># is not a number</span>
                    <span class="n">mparams</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">jointfitparams</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">param_name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>
                    <span class="n">plen</span> <span class="o">=</span> <span class="n">slice_</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">slice_</span><span class="o">.</span><span class="n">start</span>
                    <span class="n">mparams</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">mfparams</span><span class="p">[:</span><span class="n">plen</span><span class="p">])</span>
                    <span class="k">del</span> <span class="n">mfparams</span><span class="p">[:</span><span class="n">plen</span><span class="p">]</span>
            <span class="n">model</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mparams</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_convert_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_models</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert inputs to float arrays.&quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">data_ndim</span><span class="p">,</span> <span class="n">data_shape</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_ndim</span><span class="p">,</span> <span class="n">data_shape</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># For compatibility with how the linear fitter code currently expects to</span>
    <span class="c1"># work, shift the dependent variable&#39;s axes to the expected locations</span>
    <span class="k">if</span> <span class="n">n_models</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">data_ndim</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">model_set_axis</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">data_ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;model_set_axis out of range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_shape</span><span class="p">[</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_models</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Number of data sets (y or z array) is expected to equal &quot;</span>
                <span class="s2">&quot;the number of parameter sets&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># For a 1-D model the y coordinate&#39;s model-set-axis is expected to</span>
            <span class="c1"># be last, so that its first dimension is the same length as the x</span>
            <span class="c1"># coordinates.  This is in line with the expectations of</span>
            <span class="c1"># numpy.linalg.lstsq:</span>
            <span class="c1"># https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html</span>
            <span class="c1"># That is, each model should be represented by a column.  TODO:</span>
            <span class="c1"># Obviously this is a detail of np.linalg.lstsq and should be</span>
            <span class="c1"># handled specifically by any fitters that use it...</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">model_set_axis</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">data_shape</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Shape of z excluding model_set_axis</span>
            <span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">model_set_axis</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">model_set_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>

    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_shape</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y should have the same shape&quot;</span><span class="p">)</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data_shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x, y and z should have the same shape&quot;</span><span class="p">)</span>
        <span class="n">farg</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">farg</span>


<span class="c1"># TODO: These utility functions are really particular to handling</span>
<span class="c1"># bounds/tied/fixed constraints for scipy.optimize optimizers that do not</span>
<span class="c1"># support them inherently; this needs to be reworked to be clear about this</span>
<span class="c1"># distinction (and the fact that these are not necessarily applicable to any</span>
<span class="c1"># arbitrary fitter--as evidenced for example by the fact that JointFitter has</span>
<span class="c1"># its own versions of these)</span>
<span class="c1"># TODO: Most of this code should be entirely rewritten; it should not be as</span>
<span class="c1"># inefficient as it is.</span>
<span class="k">def</span> <span class="nf">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="n">use_min_max_bounds</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the full list of model parameters from the fitted and</span>
<span class="sd">    constrained parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model :</span>
<span class="sd">        The model being fit</span>
<span class="sd">    fps :</span>
<span class="sd">        The fit parameter values to be assigned</span>
<span class="sd">    use_min_max_bounds: bool</span>
<span class="sd">        If the set parameter bounds for model will be enforced on each</span>
<span class="sd">        parameter with bounds.</span>
<span class="sd">        Default: True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">fit_param_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

    <span class="n">has_tied</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">has_fixed</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">has_bound</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">has_tied</span> <span class="ow">or</span> <span class="n">has_fixed</span> <span class="ow">or</span> <span class="n">has_bound</span><span class="p">):</span>
        <span class="c1"># We can just assign directly</span>
        <span class="n">model</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">fps</span>
        <span class="k">return</span>

    <span class="n">fit_param_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fit_param_indices</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">param_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_param_metrics</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fit_param_indices</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="c1"># This is determining which range of fps (the fitted parameters) maps</span>
        <span class="c1"># to parameters of the model</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">fps</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span>

        <span class="c1"># Check bounds constraints</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_min_max_bounds</span><span class="p">:</span>
            <span class="n">_min</span><span class="p">,</span> <span class="n">_max</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">_min</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">_max</span><span class="p">)</span>

        <span class="n">parameters</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">size</span>

    <span class="c1"># Update model parameters before calling ``tied`` constraints.</span>
    <span class="n">model</span><span class="o">.</span><span class="n">_array_to_parameters</span><span class="p">()</span>

    <span class="c1"># This has to be done in a separate loop due to how tied parameters are</span>
    <span class="c1"># currently evaluated (the fitted parameters need to actually be *set* on</span>
    <span class="c1"># the model first, for use in evaluating the &quot;tied&quot; expression--it might be</span>
    <span class="c1"># better to change this at some point</span>
    <span class="k">if</span> <span class="n">has_tied</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">name</span><span class="p">](</span><span class="n">model</span><span class="p">)</span>
                <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>

                <span class="c1"># To handle multiple tied constraints, model parameters</span>
                <span class="c1"># need to be updated after each iteration.</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">model</span><span class="o">.</span><span class="n">_array_to_parameters</span><span class="p">()</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;5.1&#39;</span><span class="p">,</span> <span class="s1">&#39;private method: _fitter_to_model_params has been made public now&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fps</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fitter_to_model_params</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">fps</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a model instance&#39;s parameter array to an array that can be used</span>
<span class="sd">    with a fitter that doesn&#39;t natively support fixed or tied parameters.</span>
<span class="sd">    In particular, it removes fixed/tied parameters from the parameter</span>
<span class="sd">    array.</span>
<span class="sd">    These may be a subset of the model parameters, if some of them are held</span>
<span class="sd">    constant or tied.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fitparam_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">)))</span>
    <span class="n">model_params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">model_bounds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">model_params</span><span class="p">)</span>
        <span class="n">param_metrics</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_param_metrics</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">or</span> <span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                <span class="n">slice_</span> <span class="o">=</span> <span class="n">param_metrics</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;slice&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">params</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">model_bounds</span><span class="p">[</span><span class="n">slice_</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">fitparam_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">model_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bound</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model_bounds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">model_bounds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
    <span class="n">model_bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">model_bounds</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">model_params</span><span class="p">,</span> <span class="n">fitparam_indices</span><span class="p">,</span> <span class="n">model_bounds</span>


<span class="nd">@deprecated</span><span class="p">(</span><span class="s1">&#39;5.1&#39;</span><span class="p">,</span> <span class="s1">&#39;private method: _model_to_fit_params has been made public now&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">model_to_fit_params</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_validate_constraints</span><span class="p">(</span><span class="n">supported_constraints</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make sure model constraints are supported by the current fitter.&quot;&quot;&quot;</span>

    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Optimizer cannot handle </span><span class="si">{0}</span><span class="s1"> constraints.&#39;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fixed</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">and</span>
            <span class="s1">&#39;fixed&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_constraints</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">UnsupportedConstraintError</span><span class="p">(</span>
            <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;fixed parameter&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">tied</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">and</span> <span class="s1">&#39;tied&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_constraints</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedConstraintError</span><span class="p">(</span>
            <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;tied parameter&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="ow">and</span>
            <span class="s1">&#39;bounds&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_constraints</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">UnsupportedConstraintError</span><span class="p">(</span>
            <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;bound parameter&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">eqcons</span> <span class="ow">and</span> <span class="s1">&#39;eqcons&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_constraints</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedConstraintError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;equality&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">ineqcons</span> <span class="ow">and</span> <span class="s1">&#39;ineqcons&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_constraints</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedConstraintError</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;inequality&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_validate_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">supported_constraints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check that model and fitter are compatible and return a copy of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">fittable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model does not appear to be fittable.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">linear</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Model is linear in parameters; &#39;</span>
                      <span class="s1">&#39;consider using linear fitting methods.&#39;</span><span class="p">,</span>
                      <span class="n">AstropyUserWarning</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># for now only single data sets ca be fitted</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-linear fitters can only fit &quot;</span>
                         <span class="s2">&quot;one data set at a time.&quot;</span><span class="p">)</span>
    <span class="n">_validate_constraints</span><span class="p">(</span><span class="n">supported_constraints</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="n">model_copy</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">model_copy</span>


<span class="k">def</span> <span class="nf">populate_entry_points</span><span class="p">(</span><span class="n">entry_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This injects entry points into the `astropy.modeling.fitting` namespace.</span>
<span class="sd">    This provides a means of inserting a fitting routine without requirement</span>
<span class="sd">    of it being merged into astropy&#39;s core.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    entry_points : list of `~importlib.metadata.EntryPoint`</span>
<span class="sd">        entry_points are objects which encapsulate importable objects and</span>
<span class="sd">        are defined on the installation of a package.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    An explanation of entry points can be found `here</span>
<span class="sd">    &lt;http://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">entry_point</span> <span class="ow">in</span> <span class="n">entry_points</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">name</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">entry_point</span> <span class="o">=</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># This stops the fitting from choking if an entry_point produces an error.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">AstropyUserWarning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> error occurred in entry point </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">entry_point</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">AstropyUserWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Modeling entry point </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> expected to be a Class.&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry_point</span><span class="p">,</span> <span class="n">Fitter</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry_point</span>
                    <span class="n">__all__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">AstropyUserWarning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Modeling entry point </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> expected to extend &quot;</span>
                        <span class="s2">&quot;astropy.modeling.Fitter&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_populate_ep</span><span class="p">():</span>
    <span class="c1"># TODO: Exclusively use select when Python minversion is 3.10</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">entry_points</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="s1">&#39;select&#39;</span><span class="p">):</span>
        <span class="n">populate_entry_points</span><span class="p">(</span><span class="n">ep</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;astropy.modeling&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">populate_entry_points</span><span class="p">(</span><span class="n">ep</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;astropy.modeling&#39;</span><span class="p">,</span> <span class="p">[]))</span>


<span class="n">_populate_ep</span><span class="p">()</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 20112022, The Astropy Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.4. &nbsp;
    Last built 09 May 2022. <br/>
  </p>
</footer>
  </body>
</html>