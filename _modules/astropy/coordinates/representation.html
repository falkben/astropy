


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.coordinates.representation &#8212; Astropy v5.2.dev94+gb1133d712.d20220509</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
  <meta name="robots" content="noindex, nofollow">
  
  
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v5.2.dev94+gb1133d712.d20220509</a>
	 &#187;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.coordinates.representation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">In this module, we define the coordinate representation classes, which are</span>
<span class="sd">used to represent low-level cartesian, spherical, cylindrical, and other</span>
<span class="sd">coordinates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">erfa</span> <span class="kn">import</span> <span class="n">ufunc</span> <span class="k">as</span> <span class="n">erfa_ufunc</span>

<span class="kn">from</span> <span class="nn">.angles</span> <span class="kn">import</span> <span class="n">Angle</span><span class="p">,</span> <span class="n">Longitude</span><span class="p">,</span> <span class="n">Latitude</span>
<span class="kn">from</span> <span class="nn">.distances</span> <span class="kn">import</span> <span class="n">Distance</span>
<span class="kn">from</span> <span class="nn">.matrix_utilities</span> <span class="kn">import</span> <span class="n">is_O3</span>
<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">ShapedLikeNDArray</span><span class="p">,</span> <span class="n">classproperty</span>
<span class="kn">from</span> <span class="nn">astropy.utils.data_info</span> <span class="kn">import</span> <span class="n">MixinInfo</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">DuplicateRepresentationWarning</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BaseRepresentationOrDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;BaseRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;CartesianRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;SphericalRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;UnitSphericalRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;RadialRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;PhysicsSphericalRepresentation&quot;</span><span class="p">,</span> <span class="s2">&quot;CylindricalRepresentation&quot;</span><span class="p">,</span>
           <span class="s2">&quot;BaseDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;CartesianDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;BaseSphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;BaseSphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;SphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;SphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;UnitSphericalDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;UnitSphericalCosLatDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;RadialDifferential&quot;</span><span class="p">,</span> <span class="s2">&quot;CylindricalDifferential&quot;</span><span class="p">,</span>
           <span class="s2">&quot;PhysicsSphericalDifferential&quot;</span><span class="p">]</span>

<span class="c1"># Module-level dict mapping representation string alias names to classes.</span>
<span class="c1"># This is populated by __init_subclass__ when called by Representation or</span>
<span class="c1"># Differential classes so that they are all registered automatically.</span>
<span class="n">REPRESENTATION_CLASSES</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">DIFFERENTIAL_CLASSES</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># set for tracking duplicates</span>
<span class="n">DUPLICATE_REPRESENTATIONS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="c1"># a hash for the content of the above two dicts, cached for speed.</span>
<span class="n">_REPRDIFF_HASH</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_fqn_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Get the fully qualified name of a class &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span>


<span class="k">def</span> <span class="nf">get_reprdiff_cls_hash</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a hash value that should be invariable if the</span>
<span class="sd">    `REPRESENTATION_CLASSES` and `DIFFERENTIAL_CLASSES` dictionaries have not</span>
<span class="sd">    changed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_REPRDIFF_HASH</span>
    <span class="k">if</span> <span class="n">_REPRDIFF_HASH</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_REPRDIFF_HASH</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">REPRESENTATION_CLASSES</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="o">+</span>
                          <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">_REPRDIFF_HASH</span>


<span class="k">def</span> <span class="nf">_invalidate_reprdiff_cls_hash</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_REPRDIFF_HASH</span>
    <span class="n">_REPRDIFF_HASH</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_array2string</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="c1"># Work around version differences for array2string.</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;separator&#39;</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="s1">&#39;prefix&#39;</span><span class="p">:</span> <span class="n">prefix</span><span class="p">}</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;formatter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array2string</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BaseRepresentationOrDifferentialInfo</span><span class="p">(</span><span class="n">MixinInfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for meta information like name, description, format.  This is</span>
<span class="sd">    required when the object is used as a mixin column within a table, but can</span>
<span class="sd">    be used as a general way to store meta information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrs_from_parent</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;unit&#39;</span><span class="p">}</span>  <span class="c1"># Indicates unit is read-only</span>
    <span class="n">_supports_indexing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_format</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Create numpy dtype so that numpy formatting will work.</span>
        <span class="n">components</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">components</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="p">()),</span>
                     <span class="p">[(</span><span class="n">component</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">value</span>
                      <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">values</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">component</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_represent_as_dict_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">components</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_unitstr</span>
        <span class="k">return</span> <span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">unit</span>

    <span class="k">def</span> <span class="nf">new_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new instance like ``reps`` with ``length`` rows.</span>

<span class="sd">        This is intended for creating an empty column object whose elements can</span>
<span class="sd">        be set in-place for table operations like join or vstack.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : list</span>
<span class="sd">            List of input representations or differentials.</span>
<span class="sd">        length : int</span>
<span class="sd">            Length of the output column object</span>
<span class="sd">        metadata_conflicts : str (&#39;warn&#39;|&#39;error&#39;|&#39;silent&#39;)</span>
<span class="sd">            How to handle metadata conflicts</span>
<span class="sd">        name : str</span>
<span class="sd">            Output column name</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        col : `BaseRepresentation` or `BaseDifferential` subclass instance</span>
<span class="sd">            Empty instance of this class consistent with ``cols``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get merged info attributes like shape, dtype, format, description, etc.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_cols_attributes</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">metadata_conflicts</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                                           <span class="p">(</span><span class="s1">&#39;meta&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">))</span>
        <span class="c1"># Make a new representation or differential with the desired length</span>
        <span class="c1"># using the _apply / __getitem__ machinery to effectively return</span>
        <span class="c1"># rep0[[0, 0, ..., 0, 0]]. This will have the right shape, and</span>
        <span class="c1"># include possible differentials.</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">reps</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indexes</span><span class="p">]</span>

        <span class="c1"># Use __setitem__ machinery to check whether all representations</span>
        <span class="c1"># can represent themselves as this one without loss of information.</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">reps</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;input representations are inconsistent.&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># Set (merged) info attributes.</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;meta&#39;</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="BaseRepresentationOrDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseRepresentationOrDifferential</span><span class="p">(</span><span class="n">ShapedLikeNDArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;3D coordinate representations and differentials.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comp1, comp2, comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D point or differential.  The names are the</span>
<span class="sd">        keys and the subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied; if `False`, they will be</span>
<span class="sd">        broadcast together but not use new memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure multiplication/division with ndarray or Quantity doesn&#39;t lead to</span>
    <span class="c1"># object arrays.</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">50000</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">BaseRepresentationOrDifferentialInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># make argument a list, so we can pop them off.</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="n">rep_or_diff</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">rep_or_diff</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="n">rep_or_diff</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">rep_or_diff</span><span class="o">.</span><span class="n">info</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unexpected keyword arguments for case &#39;</span>
                                <span class="sa">f</span><span class="s1">&#39;where class instance is passed in: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;__init__() missing 1 required positional &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;argument: </span><span class="si">{</span><span class="n">component</span><span class="si">!r}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

                <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;__init__() missing 1 required positional &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;argument: </span><span class="si">{</span><span class="n">component</span><span class="si">!r}</span><span class="s1"> (or first &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;argument should be an instance of &#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

                <span class="n">attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

            <span class="n">copy</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unexpected arguments: </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__init__() got multiple values for &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;argument </span><span class="si">{</span><span class="n">component</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unexpected keyword arguments: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Pass attributes through the required initializing classes.</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">[</span><span class="n">component</span><span class="p">](</span><span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bc_attrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">attrs</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span>  <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">c_str</span> <span class="o">=</span> <span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">components</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;, and &#39;</span> <span class="o">+</span> <span class="n">components</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input parameters </span><span class="si">{</span><span class="n">c_str</span><span class="si">}</span><span class="s2"> cannot be broadcast&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="c1"># The output of np.broadcast_arrays() has limitations on writeability, so we perform</span>
        <span class="c1"># additional handling to enable writeability in most situations.  This is primarily</span>
        <span class="c1"># relevant for allowing the changing of the wrap angle of longitude components.</span>
        <span class="c1">#</span>
        <span class="c1"># If the shape has changed for a given component, broadcasting is needed:</span>
        <span class="c1">#     If copy=True, we make a copy of the broadcasted array to ensure writeability.</span>
        <span class="c1">#         Note that array had already been copied prior to the broadcasting.</span>
        <span class="c1">#         TODO: Find a way to avoid the double copy.</span>
        <span class="c1">#     If copy=False, we use the broadcasted array, and writeability may still be</span>
        <span class="c1">#         limited.</span>
        <span class="c1"># If the shape has not changed for a given component, we can proceed with using the</span>
        <span class="c1">#     non-broadcasted array, which avoids writeability issues from np.broadcast_arrays().</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">bc_attr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">bc_attr</span><span class="p">)</span> <span class="k">if</span> <span class="n">bc_attr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">attr</span><span class="o">.</span><span class="n">shape</span> <span class="k">else</span> <span class="n">attr</span>
                 <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">bc_attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">bc_attrs</span><span class="p">)]</span>

        <span class="c1"># Set private attributes for the attributes. (If not defined explicitly</span>
        <span class="c1"># on the class, the metaclass will define properties to access these.)</span>
        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

<div class="viewcode-block" id="BaseRepresentationOrDifferential.get_name"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.get_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the representation or differential.</span>

<span class="sd">        In lower case, with any trailing &#39;representation&#39; or &#39;differential&#39;</span>
<span class="sd">        removed. (E.g., &#39;spherical&#39; for</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation` or</span>
<span class="sd">        `~astropy.coordinates.SphericalDifferential`.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;representation&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">14</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;differential&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">12</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">name</span></div>

    <span class="c1"># The two methods that any subclass has to define.</span>
<div class="viewcode-block" id="BaseRepresentationOrDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a representation of this class from a supplied Cartesian one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `CartesianRepresentation`</span>
<span class="sd">            The representation to turn into this class</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        representation : `BaseRepresentation` subclass instance</span>
<span class="sd">            A new representation of this class&#39;s type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: the above docstring gets overridden for differentials.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BaseRepresentationOrDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentationOrDifferential.html#astropy.coordinates.BaseRepresentationOrDifferential.to_cartesian">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the representation to its Cartesian form.</span>

<span class="sd">        Note that any differentials get dropped.</span>
<span class="sd">        Also note that orientation information at the origin is *not* preserved by</span>
<span class="sd">        conversions through Cartesian coordinates. For example, transforming</span>
<span class="sd">        an angular position defined at distance=0 through cartesian coordinates</span>
<span class="sd">        and back will lose the original angular coordinates::</span>

<span class="sd">            &gt;&gt;&gt; import astropy.units as u</span>
<span class="sd">            &gt;&gt;&gt; import astropy.coordinates as coord</span>
<span class="sd">            &gt;&gt;&gt; rep = coord.SphericalRepresentation(</span>
<span class="sd">            ...     lon=15*u.deg,</span>
<span class="sd">            ...     lat=-11*u.deg,</span>
<span class="sd">            ...     distance=0*u.pc)</span>
<span class="sd">            &gt;&gt;&gt; rep.to_cartesian().represent_as(coord.SphericalRepresentation)</span>
<span class="sd">            &lt;SphericalRepresentation (lon, lat, distance) in (rad, rad, pc)</span>
<span class="sd">                (0., 0., 0.)&gt;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cartrepr : `CartesianRepresentation`</span>
<span class="sd">            The representation in Cartesian form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: the above docstring gets overridden for differentials.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A tuple with the in-order names of the coordinate components.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equality operator</span>

<span class="sd">        This implements strict equality and requires that the representation</span>
<span class="sd">        classes are identical and that the representation data are exactly equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot compare: objects must have same class: &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> vs. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot compare: </span><span class="si">{</span><span class="n">exc</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">exc</span>

        <span class="n">out</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">comp</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new representation or differential with ``method`` applied</span>
<span class="sd">        to the component data.</span>

<span class="sd">        In typical usage, the method is any of the shape-changing methods for</span>
<span class="sd">        `~numpy.ndarray` (``reshape``, ``swapaxes``, etc.), as well as those</span>
<span class="sd">        picking particular elements (``__getitem__``, ``take``, etc.), which</span>
<span class="sd">        are all defined in `~astropy.utils.shapes.ShapedLikeNDArray`. It will be</span>
<span class="sd">        applied to the underlying arrays (e.g., ``x``, ``y``, and ``z`` for</span>
<span class="sd">        `~astropy.coordinates.CartesianRepresentation`), with the results used</span>
<span class="sd">        to create a new instance.</span>

<span class="sd">        Internally, it is also used to apply functions to the components</span>
<span class="sd">        (in particular, `~numpy.broadcast_to`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or callable</span>
<span class="sd">            If str, it is the name of a method that is applied to the internal</span>
<span class="sd">            ``components``. If callable, the function is applied.</span>
<span class="sd">        *args : tuple</span>
<span class="sd">            Any positional arguments for ``method``.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Any keyword arguments for ``method``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="n">apply_method</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">method</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">apply_method</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span><span class="p">,</span>
                    <span class="n">apply_method</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)))</span>

        <span class="c1"># Copy other &#39;info&#39; attr only if it has actually been defined.</span>
        <span class="c1"># See PR #3898 for further explanation and justification, along</span>
        <span class="c1"># with Quantity.__array_finalize__</span>
        <span class="k">if</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>

        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;can only set from object of same class: &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> vs. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span><span class="p">)[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The shape of the instance and underlying arrays.</span>

<span class="sd">        Like `~numpy.ndarray.shape`, can be set to a new shape by assigning a</span>
<span class="sd">        tuple.  Note that if different instances share some but not all</span>
<span class="sd">        underlying data, setting the shape of one instance can make the other</span>
<span class="sd">        instance unusable.  Hence, it is strongly recommended to get new,</span>
<span class="sd">        reshaped instances with the ``reshape`` method.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the new shape has the wrong total number of elements.</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If the shape of any of the components cannot be changed without the</span>
<span class="sd">            arrays being copied.  For these cases, use the ``reshape`` method</span>
<span class="sd">            (which copies any arrays that cannot be reshaped in-place).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="c1"># We keep track of arrays that were already reshaped since we may have</span>
        <span class="c1"># to return those to their original shape if a later shape-setting</span>
        <span class="c1"># fails. (This can happen since coordinates are broadcast together.)</span>
        <span class="n">reshaped</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">oldshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">val2</span> <span class="ow">in</span> <span class="n">reshaped</span><span class="p">:</span>
                        <span class="n">val2</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">oldshape</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reshaped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="c1"># Required to support multiplication and division, and defined by the base</span>
    <span class="c1"># representation and differential classes.</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">)</span>

    <span class="c1"># Follow numpy convention and make an independent copy.</span>
    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Required to support addition and subtraction, and defined by the base</span>
    <span class="c1"># representation and differential classes.</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># The following are used for repr and str</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn the coordinates into a record array with the coordinate values.</span>

<span class="sd">        The record array fields will have the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coo_items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">[(</span><span class="n">c</span><span class="p">,</span> <span class="n">coo</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">coo</span> <span class="ow">in</span> <span class="n">coo_items</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">coo</span> <span class="ow">in</span> <span class="n">coo_items</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary with the units of the coordinate components.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">component</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_unitstr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">units_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">units_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="n">units_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unitstr</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">[</span><span class="n">component</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
                           <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">unitstr</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefixstr</span> <span class="o">=</span> <span class="s1">&#39;    &#39;</span>
        <span class="n">arrstr</span> <span class="o">=</span> <span class="n">_array2string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefixstr</span><span class="p">)</span>

        <span class="n">diffstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;differentials&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">diffstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> (has differentials w.r.t.: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()]))</span>

        <span class="n">unitstr</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;in &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unitstr</span> <span class="k">else</span> <span class="s1">&#39;[dimensionless]&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">) </span><span class="si">{:s}</span><span class="se">\n</span><span class="si">{}{}{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">),</span>
            <span class="n">unitstr</span><span class="p">,</span> <span class="n">prefixstr</span><span class="p">,</span> <span class="n">arrstr</span><span class="p">,</span> <span class="n">diffstr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make an attribute getter for use in a property.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    component : str</span>
<span class="sd">        The name of the component that should be accessed.  This assumes the</span>
<span class="sd">        actual value is stored in an attribute of that name prefixed by &#39;_&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This has to be done in a function to ensure the reference to component</span>
    <span class="c1"># is not lost/redirected.</span>
    <span class="n">component</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">component</span>

    <span class="k">def</span> <span class="nf">get_component</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_component</span>


<span class="k">class</span> <span class="nc">RepresentationInfo</span><span class="p">(</span><span class="n">BaseRepresentationOrDifferentialInfo</span><span class="p">):</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_represent_as_dict_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_represent_as_dict_attrs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_differentials</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;differentials&#39;</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">attrs</span>

    <span class="k">def</span> <span class="nf">_represent_as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_represent_as_dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;differentials&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;differentials.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_construct_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="p">):</span>
        <span class="n">differentials</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;differentials.&#39;</span><span class="p">):</span>
                <span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">14</span><span class="p">:]]</span> <span class="o">=</span> <span class="nb">map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="nb">map</span><span class="p">[</span><span class="s1">&#39;differentials&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">differentials</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_construct_from_dict</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>


<div class="viewcode-block" id="BaseRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation">[docs]</a><span class="k">class</span> <span class="nc">BaseRepresentation</span><span class="p">(</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base for representing a point in a 3D coordinate system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    comp1, comp2, comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D points.  The names are the keys and the</span>
<span class="sd">        subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    differentials : dict, `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `~astropy.coordinates.BaseDifferential`</span>
<span class="sd">        subclass instance, or a dictionary with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All representation classes should subclass this base representation class,</span>
<span class="sd">    and define an ``attr_classes`` attribute, a `dict`</span>
<span class="sd">    which maps component names to the class that creates them. They must also</span>
<span class="sd">    define a ``to_cartesian`` method and a ``from_cartesian`` class method. By</span>
<span class="sd">    default, transformations are done via the cartesian system, but classes</span>
<span class="sd">    that want to define a smarter transformation path can overload the</span>
<span class="sd">    ``represent_as`` method. If one wants to use an associated differential</span>
<span class="sd">    class, one should also define ``unit_vectors`` and ``scale_factors``</span>
<span class="sd">    methods (see those methods for details).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">RepresentationInfo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Register representation name (except for BaseRepresentation)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;BaseRepresentation&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;attr_classes&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Representations must have an &#39;</span>
                                      <span class="s1">&#39;&quot;attr_classes&quot; class attribute.&#39;</span><span class="p">)</span>

        <span class="n">repr_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="c1"># first time a duplicate is added</span>
        <span class="c1"># remove first entry and add both using their qualnames</span>
        <span class="k">if</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">REPRESENTATION_CLASSES</span><span class="p">:</span>
            <span class="n">DUPLICATE_REPRESENTATIONS</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">repr_name</span><span class="p">)</span>

            <span class="n">fqn_cls</span> <span class="o">=</span> <span class="n">_fqn_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">existing</span> <span class="o">=</span> <span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span>
            <span class="n">fqn_existing</span> <span class="o">=</span> <span class="n">_fqn_class</span><span class="p">(</span><span class="n">existing</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fqn_cls</span> <span class="o">==</span> <span class="n">fqn_existing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Representation &quot;</span><span class="si">{</span><span class="n">fqn_cls</span><span class="si">}</span><span class="s1">&quot; already defined&#39;</span><span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Representation &quot;</span><span class="si">{</span><span class="n">repr_name</span><span class="si">}</span><span class="s1">&quot; already defined, removing it to avoid confusion.&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Use qualnames &quot;</span><span class="si">{</span><span class="n">fqn_cls</span><span class="si">}</span><span class="s1">&quot; and &quot;</span><span class="si">{</span><span class="n">fqn_existing</span><span class="si">}</span><span class="s1">&quot; or class instances directly&#39;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">DuplicateRepresentationWarning</span><span class="p">)</span>

            <span class="k">del</span> <span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span>
            <span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">fqn_existing</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing</span>
            <span class="n">repr_name</span> <span class="o">=</span> <span class="n">fqn_cls</span>

        <span class="c1"># further definitions with the same name, just add qualname</span>
        <span class="k">elif</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">DUPLICATE_REPRESENTATIONS</span><span class="p">:</span>
            <span class="n">fqn_cls</span> <span class="o">=</span> <span class="n">_fqn_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Representation &quot;</span><span class="si">{</span><span class="n">repr_name</span><span class="si">}</span><span class="s1">&quot; already defined, using qualname &#39;</span>
                          <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">fqn_cls</span><span class="si">}</span><span class="s1">&quot;.&#39;</span><span class="p">)</span>
            <span class="n">repr_name</span> <span class="o">=</span> <span class="n">fqn_cls</span>
            <span class="k">if</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">REPRESENTATION_CLASSES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Representation &quot;</span><span class="si">{</span><span class="n">repr_name</span><span class="si">}</span><span class="s1">&quot; already defined&#39;</span>
                <span class="p">)</span>

        <span class="n">REPRESENTATION_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">_invalidate_reprdiff_cls_hash</span><span class="p">()</span>

        <span class="c1"># define getters for any component that does not yet have one.</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span>
                        <span class="nb">property</span><span class="p">(</span><span class="n">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">),</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;The &#39;</span><span class="si">{</span><span class="n">component</span><span class="si">}</span><span class="s2">&#39; component of the points(s).&quot;</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Handle any differentials passed in.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">differentials</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">args</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)):</span>
            <span class="n">differentials</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_differentials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_differentials</span><span class="p">(</span><span class="n">differentials</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_validate_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">differentials</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that the provided differentials are appropriate for this</span>
<span class="sd">        representation and recast/reshape as necessary and then return.</span>

<span class="sd">        Note that this does *not* set the differentials on</span>
<span class="sd">        ``self._differentials``, but rather leaves that for the caller.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Now handle the actual validation of any specified differential classes</span>
        <span class="k">if</span> <span class="n">differentials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">differentials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">differentials</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="c1"># We can&#39;t handle auto-determining the key for this combo</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">differentials</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To attach a RadialDifferential to a &quot;</span>
                                 <span class="s2">&quot;UnitSphericalRepresentation, you must supply &quot;</span>
                                 <span class="s2">&quot;a dictionary with an appropriate key.&quot;</span><span class="p">)</span>

            <span class="n">key</span> <span class="o">=</span> <span class="n">differentials</span><span class="o">.</span><span class="n">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">differentials</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">differentials</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">differentials</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;differentials&#39; argument must be a &quot;</span>
                                <span class="s2">&quot;dictionary-like object&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="n">diff</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">)):</span>
                <span class="c1"># We trust the passing of a key for a RadialDifferential</span>
                <span class="c1"># attached to a UnitSphericalRepresentation because it will not</span>
                <span class="c1"># have a paired component name (UnitSphericalRepresentation has</span>
                <span class="c1"># no .distance) to automatically determine the expected key</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">expected_key</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">expected_key</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For differential object &#39;</span><span class="si">{}</span><span class="s2">&#39;, expected &quot;</span>
                                     <span class="s2">&quot;unit key = &#39;</span><span class="si">{}</span><span class="s2">&#39; but received key = &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">diff</span><span class="p">),</span> <span class="n">expected_key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

            <span class="c1"># For now, we are very rigid: differentials must have the same shape</span>
            <span class="c1"># as the representation. This makes it easier to handle __getitem__</span>
            <span class="c1"># and any other shape-changing operations on representations that</span>
            <span class="c1"># have associated differentials</span>
            <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="c1"># TODO: message of IncompatibleShapeError is not customizable,</span>
                <span class="c1">#       so use a valueerror instead?</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of differentials must be the same &quot;</span>
                                 <span class="s2">&quot;as the shape of the representation (</span><span class="si">{}</span><span class="s2"> vs &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">differentials</span>

    <span class="k">def</span> <span class="nf">_raise_if_has_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to raise a consistent exception for any operation that is not</span>
<span class="sd">        supported when a representation has differentials attached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Operation &#39;</span><span class="si">{}</span><span class="s2">&#39; is not supported when &quot;</span>
                            <span class="s2">&quot;differentials are attached to a </span><span class="si">{}</span><span class="s2">.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A dictionary of differential class instances.</span>

<span class="sd">        The keys of this dictionary must be a string representation of the SI</span>
<span class="sd">        unit with which the differential (derivative) is taken. For example, for</span>
<span class="sd">        a velocity differential on a positional representation, the key would be</span>
<span class="sd">        ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span>

    <span class="c1"># We do not make unit_vectors and scale_factors abstract methods, since</span>
    <span class="c1"># they are only necessary if one also defines an associated Differential.</span>
    <span class="c1"># Also, doing so would break pre-differential representation subclasses.</span>
<div class="viewcode-block" id="BaseRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Cartesian unit vectors in the direction of each component.</span>

<span class="sd">        Given unit vectors :math:`\hat{e}_c` and scale factors :math:`f_c`,</span>
<span class="sd">        a change in one component of :math:`\delta c` corresponds to a change</span>
<span class="sd">        in representation of :math:`\delta c \times f_c \times \hat{e}_c`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            The keys are the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> has not implemented unit vectors&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Scale factors for each component&#39;s direction.</span>

<span class="sd">        Given unit vectors :math:`\hat{e}_c` and scale factors :math:`f_c`,</span>
<span class="sd">        a change in one component of :math:`\delta c` corresponds to a change</span>
<span class="sd">        in representation of :math:`\delta c \times f_c \times \hat{e}_c`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            The keys are the component names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> has not implemented scale factors.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_re_represent_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_rep</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-represent the differentials to the specified classes.</span>

<span class="sd">        This returns a new dictionary with the same keys but with the</span>
<span class="sd">        attached differentials converted to the new differential classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">differential_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span> <span class="ow">and</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No differentials associated with this &quot;</span>
                             <span class="s2">&quot;representation!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">differential_class</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="n">differential_class</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">)):</span>
            <span class="c1"># TODO: is there a better way to do this?</span>
            <span class="n">differential_class</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">differential_class</span>
            <span class="p">}</span>

        <span class="k">elif</span> <span class="n">differential_class</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Desired differential classes must be passed in &quot;</span>
                             <span class="s2">&quot;as a dictionary with keys equal to a string &quot;</span>
                             <span class="s2">&quot;representation of the unit of the derivative &quot;</span>
                             <span class="s2">&quot;for each differential stored with this &quot;</span>
                             <span class="s2">&quot;representation object (</span><span class="si">{0}</span><span class="s2">)&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">))</span>

        <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_diffs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                 <span class="n">base</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span>
                        <span class="n">new_rep</span><span class="o">.</span><span class="n">_compatible_differentials</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Desired differential class </span><span class="si">{}</span><span class="s2"> is not &quot;</span>
                                    <span class="s2">&quot;compatible with the desired &quot;</span>
                                    <span class="s2">&quot;representation class </span><span class="si">{}</span><span class="s2">&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">differential_class</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                            <span class="n">new_rep</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">err</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">return</span> <span class="n">new_diffs</span>

<div class="viewcode-block" id="BaseRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert coordinates to another representation.</span>

<span class="sd">        If the instance is of the requested class, it is returned unmodified.</span>
<span class="sd">        By default, conversion is done via Cartesian coordinates.</span>
<span class="sd">        Also note that orientation information at the origin is *not* preserved by</span>
<span class="sd">        conversions through Cartesian coordinates. See the docstring for</span>
<span class="sd">        :meth:`~astropy.coordinates.BaseRepresentationOrDifferential.to_cartesian`</span>
<span class="sd">        for an example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_class : `~astropy.coordinates.BaseRepresentation` subclass</span>
<span class="sd">            The type of representation to turn the coordinates into.</span>
<span class="sd">        differential_class : dict of `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">            Classes in which the differentials should be represented.</span>
<span class="sd">            Can be a single class if only a single differential is attached,</span>
<span class="sd">            otherwise it should be a `dict` keyed by the same keys as the</span>
<span class="sd">            differentials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other_class</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">without_differentials</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input to a representation&#39;s represent_as &quot;</span>
                                 <span class="s2">&quot;must be a class, not a string. For &quot;</span>
                                 <span class="s2">&quot;strings, use frame objects&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">other_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
                <span class="c1"># The default is to convert via cartesian coordinates</span>
                <span class="n">new_rep</span> <span class="o">=</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_rep</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="n">new_rep</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span>
                <span class="n">new_rep</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">new_rep</span></div>

<div class="viewcode-block" id="BaseRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform coordinates using a 3x3 matrix in a Cartesian basis.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 (or stack thereof) matrix, such as a rotation matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># route transformation through Cartesian</span>
        <span class="n">difs_cls</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">CartesianDifferential</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">crep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">CartesianRepresentation</span><span class="p">,</span>
                                 <span class="n">differential_class</span><span class="o">=</span><span class="n">difs_cls</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># move back to original representation</span>
        <span class="n">difs_cls</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">diff</span><span class="o">.</span><span class="vm">__class__</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="n">crep</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">difs_cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rep</span></div>

<div class="viewcode-block" id="BaseRepresentation.with_differentials"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.with_differentials">[docs]</a>    <span class="k">def</span> <span class="nf">with_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">differentials</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new representation with the same positions as this</span>
<span class="sd">        representation, but with these new differentials.</span>

<span class="sd">        Differential keys that already exist in this object&#39;s differential dict</span>
<span class="sd">        are overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        differentials : sequence of `~astropy.coordinates.BaseDifferential` subclass instance</span>
<span class="sd">            The differentials for the new representation to have.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            A copy of this representation, but with the ``differentials`` as</span>
<span class="sd">            its differentials.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">differentials</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>

        <span class="c1"># We shallow copy the differentials dictionary so we don&#39;t update the</span>
        <span class="c1"># current object&#39;s dictionary when adding new keys</span>
        <span class="n">new_rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                 <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_rep</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">new_rep</span><span class="o">.</span><span class="n">_validate_differentials</span><span class="p">(</span><span class="n">differentials</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">new_rep</span></div>

<div class="viewcode-block" id="BaseRepresentation.without_differentials"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.without_differentials">[docs]</a>    <span class="k">def</span> <span class="nf">without_differentials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the representation without attached differentials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            A shallow copy of this representation, without any differentials.</span>
<span class="sd">            If no differentials were present, no copy is made.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseRepresentation.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance of this representation from another one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        representation : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The presentation that should be converted to this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">representation</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equality operator for BaseRepresentation</span>

<span class="sd">        This implements strict equality and requires that the representation</span>
<span class="sd">        classes are identical, the differentials are identical, and that the</span>
<span class="sd">        representation data are exactly equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># BaseRepresentationOrDifferental (checks classes and compares components)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># super() checks that the class is identical so can this even happen?</span>
        <span class="c1"># (same class, different differentials ?)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot compare: objects must have same differentials&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">self_diff</span><span class="p">,</span> <span class="n">value_diff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                                         <span class="n">value</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">out</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">self_diff</span> <span class="o">==</span> <span class="n">value_diff</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new representation with ``method`` applied to the component</span>
<span class="sd">        data.</span>

<span class="sd">        This is not a simple inherit from ``BaseRepresentationOrDifferential``</span>
<span class="sd">        because we need to call ``._apply()`` on any associated differential</span>
<span class="sd">        classes.</span>

<span class="sd">        See docstring for `BaseRepresentationOrDifferential._apply`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str or callable</span>
<span class="sd">            If str, it is the name of a method that is applied to the internal</span>
<span class="sd">            ``components``. If callable, the function is applied.</span>
<span class="sd">        *args : tuple</span>
<span class="sd">            Any positional arguments for ``method``.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Any keyword arguments for ``method``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">rep</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">diff</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">BaseRepresentation</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;value must be a representation instance, &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;value must be representable as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;without loss of information.&#39;</span><span class="p">)</span>

        <span class="n">diff_classes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">value</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;value must have the same differentials.&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">self_diff</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">diff_classes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_diff_cls</span> <span class="o">=</span> <span class="n">self_diff</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="n">value_diff_cls</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value_diff_cls</span><span class="p">,</span> <span class="n">self_diff_cls</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value_diff_cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">)</span>
                            <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_diff_cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;value differential </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s1"> must be representable as &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">self_diff</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> without loss of information.&#39;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">diff_classes</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">differential</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale all non-angular components, leaving angular ones unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.mul`, `~operator.neg`, etc.</span>
<span class="sd">        *args</span>
<span class="sd">            Any arguments required for the operator (typically, what is to</span>
<span class="sd">            be multiplied with, divided by).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Angle</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="c1"># try/except catches anything that cannot initialize the class, such</span>
        <span class="c1"># as operations that returned NotImplemented or a representation</span>
        <span class="c1"># instead of a quantity (as would happen for, e.g., rep * rep).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">diff_result</span> <span class="o">=</span> <span class="n">differential</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff_result</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two representation.</span>

<span class="sd">        By default, operate on the cartesian representations of both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The other representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="c1"># We need to override this setter to support differentials</span>
    <span class="nd">@BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="n">orig_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># See: https://stackoverflow.com/questions/3336767/ for an example</span>
        <span class="n">BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># also try to perform shape-setting on any associated differentials</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">BaseRepresentationOrDifferential</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orig_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span>

            <span class="k">raise</span>

<div class="viewcode-block" id="BaseRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                           <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_classes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                           <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Angle</span><span class="p">))))</span></div>

<div class="viewcode-block" id="BaseRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        Averaging is done by converting the representation to cartesian, and</span>
<span class="sd">        taking the mean of the x, y, and z components. The result is converted</span>
<span class="sd">        back to the same representation as the input.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            Vector mean, in the same representation as that of the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        Adding is done by converting the representation to cartesian, and</span>
<span class="sd">        summing the x, y, and z components. The result is converted back to the</span>
<span class="sd">        same representation as the input.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            Vector sum, in the same representation as that of the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="BaseRepresentation.dot"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation`</span>
<span class="sd">            The representation to take the dot product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : `~astropy.units.Quantity`</span>
<span class="sd">            The sum of the product of the x, y, and z components of the</span>
<span class="sd">            cartesian representations of ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseRepresentation.html#astropy.coordinates.BaseRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector cross product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`, and converting the</span>
<span class="sd">        result back to the type of representation of ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The representation to take the cross product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``, in the</span>
<span class="sd">            same type of representation as ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="CartesianRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation">[docs]</a><span class="k">class</span> <span class="nc">CartesianRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : `~astropy.units.Quantity` or array</span>
<span class="sd">        The x, y, and z coordinates of the point(s). If ``x``, ``y``, and ``z``</span>
<span class="sd">        have different shapes, they should be broadcastable. If not quantity,</span>
<span class="sd">        ``unit`` should be set.  If only ``x`` is given, it is assumed that it</span>
<span class="sd">        contains an array with the 3 coordinates stored along ``xyz_axis``.</span>
<span class="sd">    unit : unit-like</span>
<span class="sd">        If given, the coordinates will be converted to this unit (or taken to</span>
<span class="sd">        be in this unit if not given.</span>
<span class="sd">    xyz_axis : int, optional</span>
<span class="sd">        The axis along which the coordinates are stored when a single array is</span>
<span class="sd">        provided rather than distinct ``x``, ``y``, and ``z`` (default: 0).</span>

<span class="sd">    differentials : dict, `CartesianDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `CartesianDifferential` instance, or a dictionary of</span>
<span class="sd">        `CartesianDifferential` s with keys set to a string representation of</span>
<span class="sd">        the SI unit with which the differential (derivative) is taken. For</span>
<span class="sd">        example, for a velocity differential on a positional representation, the</span>
<span class="sd">        key would be ``&#39;s&#39;`` for seconds, indicating that the derivative is a</span>
<span class="sd">        time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="n">_xyz</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;OV&#39;</span><span class="p">:</span>
                <span class="c1"># Short-cut for 3-D array input.</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># Keep a link to the array with all three coordinates</span>
                <span class="c1"># so that we can return it quickly if needed in get_xyz.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_xyz</span> <span class="o">=</span> <span class="n">x</span>
                <span class="k">if</span> <span class="n">xyz_axis</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">=</span> <span class="n">xyz_axis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_differentials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_differentials</span><span class="p">(</span><span class="n">differentials</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">CartesianRepresentation</span><span class="p">)</span>
                  <span class="ow">and</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">differentials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">differentials</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_differentials</span>

                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">,</span>
                                        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">if</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xyz_axis should only be set if x, y, and z are &quot;</span>
                             <span class="s2">&quot;in a single array passed in through x, &quot;</span>
                             <span class="s2">&quot;i.e., y and z should not be not given.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x, y, and z are required to instantiate </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="o">.</span><span class="n">unit</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;x, y, and z should have matching physical types&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">0.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span></div>

<div class="viewcode-block" id="CartesianRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">}</span></div>

<div class="viewcode-block" id="CartesianRepresentation.get_xyz"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.get_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">get_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector array of the x, y, and z coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_axis : int, optional</span>
<span class="sd">            The axis in the final array along which the x, y, z components</span>
<span class="sd">            should be stored (default: 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xyz : `~astropy.units.Quantity`</span>
<span class="sd">            With dimension 3 along ``xyz_axis``.  Note that, if possible,</span>
<span class="sd">            this will be a view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">==</span> <span class="n">xyz_axis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">)</span>

        <span class="c1"># Create combined array.  TO DO: keep it in _xyz for repeated use?</span>
        <span class="c1"># But then in-place changes have to cancel it. Likely best to</span>
        <span class="c1"># also update components.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">xyz_axis</span><span class="p">)</span></div>

    <span class="n">xyz</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_xyz</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">other</span></div>

<div class="viewcode-block" id="CartesianRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CartesianRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the cartesian coordinates using a 3x3 matrix.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : ndarray</span>
<span class="sd">            A 3x3 transformation matrix, such as a rotation matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We can start off by creating a cartesian representation object:</span>

<span class="sd">            &gt;&gt;&gt; from astropy import units as u</span>
<span class="sd">            &gt;&gt;&gt; from astropy.coordinates import CartesianRepresentation</span>
<span class="sd">            &gt;&gt;&gt; rep = CartesianRepresentation([1, 2] * u.pc,</span>
<span class="sd">            ...                               [2, 3] * u.pc,</span>
<span class="sd">            ...                               [3, 4] * u.pc)</span>

<span class="sd">        We now create a rotation matrix around the z axis:</span>

<span class="sd">            &gt;&gt;&gt; from astropy.coordinates.matrix_utilities import rotation_matrix</span>
<span class="sd">            &gt;&gt;&gt; rotation = rotation_matrix(30 * u.deg, axis=&#39;z&#39;)</span>

<span class="sd">        Finally, we can apply this transformation:</span>

<span class="sd">            &gt;&gt;&gt; rep_new = rep.transform(rotation)</span>
<span class="sd">            &gt;&gt;&gt; rep_new.xyz  # doctest: +FLOAT_CMP</span>
<span class="sd">            &lt;Quantity [[ 1.8660254 , 3.23205081],</span>
<span class="sd">                       [ 1.23205081, 1.59807621],</span>
<span class="sd">                       [ 3.        , 4.        ]] pc&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># erfa rxp: Multiply a p-vector by an r-matrix.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">rxp</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># transformed representation</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Handle differentials attached to this representation</span>
        <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">rep</span><span class="o">.</span><span class="n">with_differentials</span><span class="p">(</span><span class="n">new_diffs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_c</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span>
                         <span class="p">(</span><span class="n">other_c</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">component</span><span class="p">),</span>
                                   <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">component</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>

<div class="viewcode-block" id="CartesianRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># erfa pm: Modulus of p-vector.</span>
        <span class="k">return</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">pm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="CartesianRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        Returns a new CartesianRepresentation instance with the means of the</span>
<span class="sd">        x, y, and z components.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        Returns a new CartesianRepresentation instance with the sums of the</span>
<span class="sd">        x, y, and z components.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianRepresentation.dot"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dot product of two representations.</span>

<span class="sd">        Note that any associated differentials will be dropped during this</span>
<span class="sd">        operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            If not already cartesian, it is converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dot_product : `~astropy.units.Quantity`</span>
<span class="sd">            The sum of the product of the x, y, and z components of ``self``</span>
<span class="sd">            and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot only take dot product with another &quot;</span>
                            <span class="s2">&quot;representation, not a </span><span class="si">{}</span><span class="s2"> instance.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="c1"># erfa pdp: p-vector inner (=scalar=dot) product.</span>
        <span class="k">return</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">pdp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="n">other_c</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="CartesianRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianRepresentation.html#astropy.coordinates.CartesianRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cross product of two representations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            If not already cartesian, it is converted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : `~astropy.coordinates.CartesianRepresentation`</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_c</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot only take cross product with another &quot;</span>
                            <span class="s2">&quot;representation, not a </span><span class="si">{}</span><span class="s2"> instance.&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="c1"># erfa pxp: p-vector outer (=vector=cross) product.</span>
        <span class="n">sxo</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">pxp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                             <span class="n">other_c</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">sxo</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="UnitSphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon, lat : `~astropy.units.Quantity` [&#39;angle&#39;] or str</span>
<span class="sd">        The longitude and latitude of the point(s), in angular units. The</span>
<span class="sd">        latitude should be between -90 and 90 degrees, and the longitude will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`,</span>
<span class="sd">        `~astropy.coordinates.Longitude`, or `~astropy.coordinates.Latitude`.</span>

<span class="sd">    differentials : dict, `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `~astropy.coordinates.BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">Longitude</span><span class="p">,</span>
                    <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">Latitude</span><span class="p">}</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalRepresentation</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">SphericalDifferential</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">RadialDifferential</span><span class="p">]</span>

    <span class="c1"># Could let the metaclass define these automatically, but good to have</span>
    <span class="c1"># a bit clearer docstrings.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The latitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">sinlat</span><span class="p">,</span> <span class="n">coslat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                           <span class="n">coslat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omit_coslat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sf_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">u</span><span class="o">.</span><span class="n">radian</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sf_lon</span> <span class="o">=</span> <span class="n">sf_lat</span> <span class="k">if</span> <span class="n">omit_coslat</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">sf_lon</span><span class="p">,</span>
                <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">sf_lat</span><span class="p">}</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># erfa s2c: Convert [unit]spherical coordinates to Cartesian.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">s2c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">cart</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># erfa c2s: P-vector to [unit]spherical coordinates.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">c2s</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>
        <span class="c1"># TODO! for differential_class. This cannot (currently) be implemented</span>
        <span class="c1"># like in the other Representations since `_re_represent_differentials`</span>
        <span class="c1"># keeps differentials&#39; unit keys, but this can result in a mismatch</span>
        <span class="c1"># between the UnitSpherical expected key (e.g. &quot;s&quot;) and that expected</span>
        <span class="c1"># in the other class (here &quot;s / m&quot;). For more info, see PR #11467</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">differential_class</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                   <span class="n">r</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transform the unit-spherical coordinates using a 3x3 matrix.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 matrix, such as a rotation matrix (or a stack of matrices).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `UnitSphericalRepresentation` or `SphericalRepresentation`</span>
<span class="sd">            If ``matrix`` is O(3) -- :math:`M \dot M^T = I` -- like a rotation,</span>
<span class="sd">            then the result is a `UnitSphericalRepresentation`.</span>
<span class="sd">            All other matrices will change the distance, so the dimensional</span>
<span class="sd">            representation is used instead.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the transformation matrix does not need to be a rotation matrix,</span>
        <span class="c1"># so the unit-distance is not guaranteed. For speed, we check if the</span>
        <span class="c1"># matrix is in O(3) and preserves lengths.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_O3</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>  <span class="c1"># remain in unit-rep</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">s2c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">rxp</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">c2s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">)</span>
            <span class="c1"># handle differentials</span>
            <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">rep</span><span class="o">.</span><span class="n">with_differentials</span><span class="p">(</span><span class="n">new_diffs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># switch to dimensional representation</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="p">(</span>
                <span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">differentials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rep</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="p">(</span>
            <span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">differentials</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="p">)</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">differential</span><span class="o">.</span><span class="n">base_representation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
               <span class="k">for</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__neg__</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span> <span class="o">+</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_comps</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">differential</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">),</span>
                                             <span class="n">differential</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">differential</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">new_comps</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units, which is</span>
<span class="sd">        always unity for vectors on the unit sphere.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `~astropy.units.Quantity` [&#39;dimensionless&#39;]</span>
<span class="sd">            Dimensionless ones, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">,</span>
                          <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalRepresentation.mean"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector mean.</span>

<span class="sd">        The representation is converted to cartesian, the means of the x, y,</span>
<span class="sd">        and z components are calculated, and the result is converted to a</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Refer to `~numpy.mean` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.sum"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector sum.</span>

<span class="sd">        The representation is converted to cartesian, the sums of the x, y,</span>
<span class="sd">        and z components are calculated, and the result is converted to a</span>
<span class="sd">        `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Refer to `~numpy.sum` for full documentation of the arguments, noting</span>
<span class="sd">        that ``axis`` is the entry in the ``shape`` of the representation, and</span>
<span class="sd">        that the ``out`` argument cannot be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<div class="viewcode-block" id="UnitSphericalRepresentation.cross"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalRepresentation.html#astropy.coordinates.UnitSphericalRepresentation.cross">[docs]</a>    <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cross product of two representations.</span>

<span class="sd">        The calculation is done by converting both ``self`` and ``other``</span>
<span class="sd">        to `~astropy.coordinates.CartesianRepresentation`, and converting the</span>
<span class="sd">        result back to `~astropy.coordinates.SphericalRepresentation`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The representation to take the cross product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cross_product : `~astropy.coordinates.SphericalRepresentation`</span>
<span class="sd">            With vectors perpendicular to both ``self`` and ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_if_has_differentials</span><span class="p">(</span><span class="s1">&#39;cross&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_representation</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RadialRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation">[docs]</a><span class="k">class</span> <span class="nc">RadialRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of the distance of points from the origin.</span>

<span class="sd">    Note that this is mostly intended as an internal helper representation.</span>
<span class="sd">    It can do little else but being used as a scale in multiplication.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    distance : `~astropy.units.Quantity` [&#39;length&#39;]</span>
<span class="sd">        The distance of the point(s) from the origin.</span>

<span class="sd">    differentials : dict, `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `~astropy.coordinates.BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="RadialRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian unit vectors are undefined for radial representation.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cartesian unit vectors are undefined for &#39;</span>
                                  <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> instances&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="RadialRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">}</span></div>

<div class="viewcode-block" id="RadialRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cannot convert radial representation to cartesian.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;cannot convert </span><span class="si">{}</span><span class="s1"> instance to cartesian.&#39;</span>
                                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span></div>

<div class="viewcode-block" id="RadialRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to radial coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">cart</span><span class="o">.</span><span class="n">norm</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseRepresentation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="RadialRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        Just the distance itself.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `~astropy.units.Quantity` [&#39;dimensionless&#39;]</span>
<span class="sd">            Dimensionless ones, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

<div class="viewcode-block" id="RadialRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialRepresentation.html#astropy.coordinates.RadialRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radial representations cannot be transformed by a Cartesian matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : array-like</span>
<span class="sd">            The transformation matrix in a Cartesian basis.</span>
<span class="sd">            Must be a multiplication: a diagonal matrix with identical elements.</span>
<span class="sd">            Must have shape (..., 3, 3), where the last 2 indices are for the</span>
<span class="sd">            matrix on each other axis. Make sure that the matrix shape is</span>
<span class="sd">            compatible with the shape of this representation.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the matrix is not a multiplication.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># check that the matrix is a scaled identity matrix on the last 2 axes.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">matrix</span> <span class="o">!=</span> <span class="n">scl</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Radial representations can only be &quot;</span>
                             <span class="s2">&quot;transformed by a scaled identity matrix&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">scl</span></div></div>


<span class="k">def</span> <span class="nf">_spherical_op_funcs</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For given operator, return functions that adjust lon, lat, distance.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">180</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">scale_sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="c1"># This should always work, even if perhaps we get a negative distance.</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">180</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">scale_sign</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">scale_sign</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>


<div class="viewcode-block" id="SphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">SphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lon, lat : `~astropy.units.Quantity` [&#39;angle&#39;]</span>
<span class="sd">        The longitude and latitude of the point(s), in angular units. The</span>
<span class="sd">        latitude should be between -90 and 90 degrees, and the longitude will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`,</span>
<span class="sd">        `~astropy.coordinates.Longitude`, or `~astropy.coordinates.Latitude`.</span>

<span class="sd">    distance : `~astropy.units.Quantity` [&#39;length&#39;]</span>
<span class="sd">        The distance to the point(s). If the distance is a length, it is</span>
<span class="sd">        passed to the :class:`~astropy.coordinates.Distance` class, otherwise</span>
<span class="sd">        it is passed to the :class:`~astropy.units.Quantity` class.</span>

<span class="sd">    differentials : dict, `~astropy.coordinates.BaseDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single `~astropy.coordinates.BaseDifferential`</span>
<span class="sd">        instance (see `._compatible_differentials` for valid types), or a</span>
<span class="sd">        dictionary of of differential instances with keys set to a string</span>
<span class="sd">        representation of the SI unit with which the differential (derivative)</span>
<span class="sd">        is taken. For example, for a velocity differential on a positional</span>
<span class="sd">        representation, the key would be ``&#39;s&#39;`` for seconds, indicating that</span>
<span class="sd">        the derivative is a time derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">Longitude</span><span class="p">,</span>
                    <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">Latitude</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>
    <span class="n">_unit_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                         <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">,</span> <span class="n">Distance</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span> <span class="o">=</span> <span class="n">Distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;distance must be &gt;= 0&#39;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Distance must be &gt;= 0. To allow negative &quot;</span>
                                     <span class="s2">&quot;distance values, you must explicitly pass&quot;</span>
                                     <span class="s2">&quot; in a `Distance` object with the the &quot;</span>
                                     <span class="s2">&quot;argument &#39;allow_negative=True&#39;.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_compatible_differentials</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">UnitSphericalDifferential</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">SphericalDifferential</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                <span class="n">RadialDifferential</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The longitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The latitude of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lat</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance</span>

<div class="viewcode-block" id="SphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">sinlat</span><span class="p">,</span> <span class="n">coslat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlon</span><span class="p">,</span> <span class="n">coslon</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="o">-</span><span class="n">sinlat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                           <span class="n">coslat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">coslat</span><span class="o">*</span><span class="n">coslon</span><span class="p">,</span> <span class="n">coslat</span><span class="o">*</span><span class="n">sinlon</span><span class="p">,</span>
                                                <span class="n">sinlat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span></div>

<div class="viewcode-block" id="SphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omit_coslat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">sf_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">sf_lon</span> <span class="o">=</span> <span class="n">sf_lat</span> <span class="k">if</span> <span class="n">omit_coslat</span> <span class="k">else</span> <span class="n">sf_lat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">sf_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">sf_lon</span><span class="p">,</span>
                <span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">sf_lat</span><span class="p">,</span>
                <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">sf_distance</span><span class="p">}</span></div>

<div class="viewcode-block" id="SphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>

        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
                <span class="n">diffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span>
                                                         <span class="n">differential_class</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                   <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">diffs</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
                <span class="n">diffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span>
                                                         <span class="n">differential_class</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
                                   <span class="n">differentials</span><span class="o">=</span><span class="n">diffs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to convert Distance to Quantity to allow negative values.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="n">Distance</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span>

        <span class="c1"># erfa s2p: Convert spherical polar coordinates to p-vector.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">s2p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">cart</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># erfa p2s: P-vector to spherical polar coordinates.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">p2s</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform the spherical coordinates using a 3x3 matrix.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 matrix, such as a rotation matrix (or a stack of matrices).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">s2c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">rxp</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">ur</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">p2s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ur</span><span class="p">)</span>

        <span class="c1"># handle differentials</span>
        <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">rep</span><span class="o">.</span><span class="n">with_differentials</span><span class="p">(</span><span class="n">new_diffs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalRepresentation.html#astropy.coordinates.SphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.  For</span>
<span class="sd">        spherical coordinates, this is just the absolute value of the distance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># TODO: expand special-casing to UnitSpherical and RadialDifferential.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">differential</span><span class="o">.</span><span class="n">base_representation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
               <span class="k">for</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">lon_op</span><span class="p">,</span> <span class="n">lat_op</span><span class="p">,</span> <span class="n">distance_op</span> <span class="o">=</span> <span class="n">_spherical_op_funcs</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">lon_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span> <span class="n">lat_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span>
                                <span class="n">distance_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_comps</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">differential</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">lat_op</span><span class="p">,</span> <span class="n">distance_op</span><span class="p">),</span>
                <span class="n">differential</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">differential</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">new_comps</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="PhysicsSphericalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">PhysicsSphericalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D spherical coordinates (using the physics</span>
<span class="sd">    convention of using ``phi`` and ``theta`` for azimuth and inclination</span>
<span class="sd">    from the pole).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi, theta : `~astropy.units.Quantity` or str</span>
<span class="sd">        The azimuth and inclination of the point(s), in angular units. The</span>
<span class="sd">        inclination should be between 0 and 180 degrees, and the azimuth will</span>
<span class="sd">        be wrapped to an angle between 0 and 360 degrees. These can also be</span>
<span class="sd">        instances of `~astropy.coordinates.Angle`.  If ``copy`` is False, `phi`</span>
<span class="sd">        will be changed inplace if it is not between 0 and 360 degrees.</span>

<span class="sd">    r : `~astropy.units.Quantity`</span>
<span class="sd">        The distance to the point(s). If the distance is a length, it is</span>
<span class="sd">        passed to the :class:`~astropy.coordinates.Distance` class, otherwise</span>
<span class="sd">        it is passed to the :class:`~astropy.units.Quantity` class.</span>

<span class="sd">    differentials : dict, `PhysicsSphericalDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `PhysicsSphericalDifferential` instance, or a dictionary of of</span>
<span class="sd">        differential instances with keys set to a string representation of the</span>
<span class="sd">        SI unit with which the differential (derivative) is taken. For example,</span>
<span class="sd">        for a velocity differential on a positional representation, the key</span>
<span class="sd">        would be ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
                    <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
                    <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>

        <span class="c1"># Wrap/validate phi/theta</span>
        <span class="c1"># Note that _phi already holds our own copy if copy=True.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span><span class="o">.</span><span class="n">wrap_at</span><span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># This invalid catch block can be removed when the minimum numpy</span>
        <span class="c1"># version is &gt;= 1.19 (NUMPY_LT_1_19)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_theta</span> <span class="o">&gt;</span> <span class="mf">180.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Inclination angle(s) must be within &#39;</span>
                                 <span class="s1">&#39;0 deg &lt;= angle &lt;= 180 deg, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">degree</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">physical_type</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">Distance</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The azimuth of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">theta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The elevation of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance from the origin to the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">sintheta</span><span class="p">,</span> <span class="n">costheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">costheta</span><span class="o">*</span><span class="n">cosphi</span><span class="p">,</span>
                                             <span class="n">costheta</span><span class="o">*</span><span class="n">sinphi</span><span class="p">,</span>
                                             <span class="o">-</span><span class="n">sintheta</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">sintheta</span><span class="o">*</span><span class="n">cosphi</span><span class="p">,</span> <span class="n">sintheta</span><span class="o">*</span><span class="n">sinphi</span><span class="p">,</span>
                                         <span class="n">costheta</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">sintheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sintheta</span><span class="p">,</span>
                <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span>
                <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">}</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Take a short cut if the other class is a spherical representation</span>

        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
                <span class="n">diffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span>
                                                         <span class="n">differential_class</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                   <span class="n">distance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">diffs</span><span class="p">,</span>
                                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalRepresentation</span><span class="p">):</span>
                <span class="n">diffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_represent_differentials</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span>
                                                         <span class="n">differential_class</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="mi">90</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">deg</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span>
                                   <span class="n">differentials</span><span class="o">=</span><span class="n">diffs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">differential_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts spherical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to convert Distance to Quantity to allow negative values.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">Distance</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to spherical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform the spherical coordinates using a 3x3 matrix.</span>

<span class="sd">        This returns a new representation and does not modify the original one.</span>
<span class="sd">        Any differentials attached to this representation will also be</span>
<span class="sd">        transformed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 matrix, such as a rotation matrix (or a stack of matrices).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># apply transformation in unit-spherical coordinates</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">s2c</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">,</span> <span class="mi">90</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">rxp</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">ur</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">p2s</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># `ur` is transformed unit-`r`</span>
        <span class="c1"># create transformed physics-spherical representation,</span>
        <span class="c1"># reapplying the distance scaling</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">phi</span><span class="o">=</span><span class="n">lon</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mi">90</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="o">-</span><span class="n">lat</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">ur</span><span class="p">)</span>

        <span class="n">new_diffs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">rep</span><span class="o">.</span><span class="n">with_differentials</span><span class="p">(</span><span class="n">new_diffs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalRepresentation.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalRepresentation.html#astropy.coordinates.PhysicsSphericalRepresentation.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.  For</span>
<span class="sd">        spherical coordinates, this is just the absolute value of the radius.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">differential</span><span class="o">.</span><span class="n">base_representation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
               <span class="k">for</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">phi_op</span><span class="p">,</span> <span class="n">adjust_theta_sign</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">_spherical_op_funcs</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># Also run phi_op on theta to ensure theta remains between 0 and 180:</span>
        <span class="c1"># any time the scale is negative, we do -theta + 180 degrees.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">phi_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span>
                                <span class="n">phi_op</span><span class="p">(</span><span class="n">adjust_theta_sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)),</span>
                                <span class="n">r_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_comps</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">differential</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">adjust_theta_sign</span><span class="p">,</span> <span class="n">r_op</span><span class="p">),</span>
                <span class="n">differential</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">differential</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">new_comps</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="CylindricalRepresentation"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation">[docs]</a><span class="k">class</span> <span class="nc">CylindricalRepresentation</span><span class="p">(</span><span class="n">BaseRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of points in 3D cylindrical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rho : `~astropy.units.Quantity`</span>
<span class="sd">        The distance from the z axis to the point(s).</span>

<span class="sd">    phi : `~astropy.units.Quantity` or str</span>
<span class="sd">        The azimuth of the point(s), in angular units, which will be wrapped</span>
<span class="sd">        to an angle between 0 and 360 degrees. This can also be instances of</span>
<span class="sd">        `~astropy.coordinates.Angle`,</span>

<span class="sd">    z : `~astropy.units.Quantity`</span>
<span class="sd">        The z coordinate(s) of the point(s)</span>

<span class="sd">    differentials : dict, `CylindricalDifferential`, optional</span>
<span class="sd">        Any differential classes that should be associated with this</span>
<span class="sd">        representation. The input must either be a single</span>
<span class="sd">        `CylindricalDifferential` instance, or a dictionary of of differential</span>
<span class="sd">        instances with keys set to a string representation of the SI unit with</span>
<span class="sd">        which the differential (derivative) is taken. For example, for a</span>
<span class="sd">        velocity differential on a positional representation, the key would be</span>
<span class="sd">        ``&#39;s&#39;`` for seconds, indicating that the derivative is a time</span>
<span class="sd">        derivative.</span>

<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">Angle</span><span class="p">,</span>
                    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">differentials</span><span class="o">=</span><span class="n">differentials</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;rho and z should have matching physical types&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The distance of the point(s) from the z-axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rho</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The azimuth of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The height of the point(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span>

<div class="viewcode-block" id="CylindricalRepresentation.unit_vectors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.unit_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">unit_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">cosphi</span><span class="p">,</span> <span class="n">sinphi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">-</span><span class="n">sinphi</span><span class="p">,</span> <span class="n">cosphi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)}</span></div>

<div class="viewcode-block" id="CylindricalRepresentation.scale_factors"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.scale_factors">[docs]</a>    <span class="k">def</span> <span class="nf">scale_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">radian</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="mf">1.</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">,</span>
                <span class="s1">&#39;phi&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="p">,</span>
                <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">l</span><span class="p">}</span></div>

<div class="viewcode-block" id="CylindricalRepresentation.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts 3D rectangular cartesian coordinates to cylindrical polar</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">cart</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">cart</span><span class="o">.</span><span class="n">z</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CylindricalRepresentation.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalRepresentation.html#astropy.coordinates.CylindricalRepresentation.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts cylindrical polar coordinates to 3D rectangular cartesian</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span>

        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">differential</span><span class="o">.</span><span class="n">base_representation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
               <span class="k">for</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">phi_op</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rho_op</span> <span class="o">=</span> <span class="n">_spherical_op_funcs</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">z_op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">rho_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">),</span> <span class="n">phi_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">),</span>
                                <span class="n">z_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">differential</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">differentials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_comps</span> <span class="o">=</span> <span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">differential</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="p">(</span><span class="n">rho_op</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">z_op</span><span class="p">),</span> <span class="n">differential</span><span class="o">.</span><span class="n">components</span><span class="p">))</span>
            <span class="n">result</span><span class="o">.</span><span class="n">differentials</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">differential</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">new_comps</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="BaseDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseDifferential</span><span class="p">(</span><span class="n">BaseRepresentationOrDifferential</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A base class representing differentials of representations.</span>

<span class="sd">    These represent differences or derivatives along each component.</span>
<span class="sd">    E.g., for physics spherical coordinates, these would be</span>
<span class="sd">    :math:`\delta r, \delta \theta, \delta \phi`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_comp1, d_comp2, d_comp3 : `~astropy.units.Quantity` or subclass</span>
<span class="sd">        The components of the 3D differentials.  The names are the keys and the</span>
<span class="sd">        subclasses the values of the ``attr_classes`` attribute.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All differential representation classes should subclass this base class,</span>
<span class="sd">    and define an ``base_representation`` attribute with the class of the</span>
<span class="sd">    regular `~astropy.coordinates.BaseRepresentation` for which differential</span>
<span class="sd">    coordinates are provided. This will set up a default ``attr_classes``</span>
<span class="sd">    instance with names equal to the base component names prefixed by ``d_``,</span>
<span class="sd">    and all classes set to `~astropy.units.Quantity`, plus properties to access</span>
<span class="sd">    those, and a default ``__init__`` for initialization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set default ``attr_classes`` and component getters on a Differential.</span>
<span class="sd">        class BaseDifferential(BaseRepresentationOrDifferential):</span>

<span class="sd">        For these, the components are those of the base representation prefixed</span>
<span class="sd">        by &#39;d_&#39;, and the class is `~astropy.units.Quantity`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Don&#39;t do anything for base helper classes.</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;BaseDifferential&#39;</span><span class="p">,</span> <span class="s1">&#39;BaseSphericalDifferential&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;BaseSphericalCosLatDifferential&#39;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;base_representation&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Differential representations must have a&#39;</span>
                                      <span class="s1">&#39;&quot;base_representation&quot; class attribute.&#39;</span><span class="p">)</span>

        <span class="c1"># If not defined explicitly, create attr_classes.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;attr_classes&#39;</span><span class="p">):</span>
            <span class="n">base_attr_classes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_representation</span><span class="o">.</span><span class="n">attr_classes</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d_&#39;</span> <span class="o">+</span> <span class="n">c</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span>
                                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">base_attr_classes</span><span class="p">}</span>

        <span class="n">repr_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">repr_name</span> <span class="ow">in</span> <span class="n">DIFFERENTIAL_CLASSES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Differential class </span><span class="si">{</span><span class="n">repr_name</span><span class="si">}</span><span class="s2"> already defined&quot;</span><span class="p">)</span>

        <span class="n">DIFFERENTIAL_CLASSES</span><span class="p">[</span><span class="n">repr_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="n">_invalidate_reprdiff_cls_hash</span><span class="p">()</span>

        <span class="c1"># If not defined explicitly, create properties for the components.</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">attr_classes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span>
                        <span class="nb">property</span><span class="p">(</span><span class="n">_make_getter</span><span class="p">(</span><span class="n">component</span><span class="p">),</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Component &#39;</span><span class="si">{</span><span class="n">component</span><span class="si">}</span><span class="s2">&#39; of the Differential.&quot;</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_check_base</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">_compatible_differentials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Differential class </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> is not compatible with the &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;base (representation) class </span><span class="si">{</span><span class="n">base</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_deriv_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a base (representation instance), determine the unit of the</span>
<span class="sd">        derivative by removing the representation unit from the component units</span>
<span class="sd">        of this differential.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This check is just a last resort so we don&#39;t return a strange unit key</span>
        <span class="c1"># from accidentally passing in the wrong base.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">d_comp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;d_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d_comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">d_unit</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">d_comp</span><span class="o">.</span><span class="n">unit</span>

                <span class="c1"># This is quite a bit faster than using to_system() or going</span>
                <span class="c1"># through Quantity()</span>
                <span class="n">d_unit_si</span> <span class="o">=</span> <span class="n">d_unit</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">si</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span>
                <span class="n">d_unit_si</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># remove the scale from the unit</span>

                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">d_unit_si</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid representation-differential units! This&quot;</span>
                               <span class="s2">&quot; likely happened because either the &quot;</span>
                               <span class="s2">&quot;representation or the associated differential &quot;</span>
                               <span class="s2">&quot;have non-standard units. Check that the input &quot;</span>
                               <span class="s2">&quot;positional data have positional units, and the &quot;</span>
                               <span class="s2">&quot;input velocity data have velocity units, or &quot;</span>
                               <span class="s2">&quot;are both dimensionless.&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_base_vectors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get unit vectors and scale factors from base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            The points for which the unit vectors and scale factors should be</span>
<span class="sd">            retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            In the directions of the coordinates of base.</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            Scale factors for each of the coordinates</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : if the base is not of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">unit_vectors</span><span class="p">(),</span> <span class="n">base</span><span class="o">.</span><span class="n">scale_factors</span><span class="p">()</span>

<div class="viewcode-block" id="BaseDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the differential to 3D rectangular cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            The points for which the differentials are to be converted: each of</span>
<span class="sd">            the components is multiplied by its unit vectors and scale factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `CartesianDifferential`</span>
<span class="sd">            This object, converted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_e</span><span class="p">,</span> <span class="n">base_sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_vectors</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">base_sf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">base_e</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">d_c</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">base</span><span class="o">.</span><span class="n">components</span><span class="p">)))</span></div>

<div class="viewcode-block" id="BaseDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the differential from 3D rectangular cartesian coordinates to</span>
<span class="sd">        the desired class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other</span>
<span class="sd">            The object to convert into this differential.</span>
<span class="sd">        base : `BaseRepresentation`</span>
<span class="sd">            The points for which the differentials are to be converted: each of</span>
<span class="sd">            the components is multiplied by its unit vectors and scale factors.</span>
<span class="sd">            Will be converted to ``cls.base_representation`` if needed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `BaseDifferential` subclass instance</span>
<span class="sd">            A new differential object that is this class&#39; type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">base_representation</span><span class="p">)</span>
        <span class="n">base_e</span><span class="p">,</span> <span class="n">base_sf</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_base_vectors</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e</span> <span class="o">/</span> <span class="n">base_sf</span><span class="p">[</span><span class="n">component</span><span class="p">])</span>
                     <span class="k">for</span> <span class="n">component</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">base_e</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert coordinates to another representation.</span>

<span class="sd">        If the instance is of the requested class, it is returned unmodified.</span>
<span class="sd">        By default, conversion is done via cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_class : `~astropy.coordinates.BaseRepresentation` subclass</span>
<span class="sd">            The type of representation to turn the coordinates into.</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined.  If the other</span>
<span class="sd">            class is a differential representation, the base will be converted</span>
<span class="sd">            to its ``base_representation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other_class</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># The default is to convert via cartesian coordinates.</span>
        <span class="n">self_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">self_cartesian</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">self_cartesian</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance of this representation from another one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        representation : `~astropy.coordinates.BaseRepresentation` instance</span>
<span class="sd">            The presentation that should be converted to this class.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base relative to which the differentials will be defined. If</span>
<span class="sd">            the representation is a differential itself, the base will be</span>
<span class="sd">            converted to its ``base_representation`` to help convert it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">BaseDifferential</span><span class="p">):</span>
            <span class="n">cartesian</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span>
                <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">base_representation</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cartesian</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">cartesian</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseDifferential.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform differential using a 3x3 matrix in a Cartesian basis.</span>

<span class="sd">        This returns a new differential and does not modify the original one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 (or stack thereof) matrix, such as a rotation matrix.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined.  If the other</span>
<span class="sd">            class is a differential representation, the base will be converted</span>
<span class="sd">            to its ``base_representation``.</span>
<span class="sd">        transformed_base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the transformed differentials are defined.</span>
<span class="sd">            If the other class is a differential representation, the base will</span>
<span class="sd">            be converted to its ``base_representation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># route transformation through Cartesian</span>
        <span class="n">cdiff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">CartesianDifferential</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span>
                                  <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="c1"># move back to original representation</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">cdiff</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">diff</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale all components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.mul`, `~operator.neg`, etc.</span>
<span class="sd">        *args</span>
<span class="sd">            Any arguments required for the operator (typically, what is to</span>
<span class="sd">            be multiplied with, divided by).</span>
<span class="sd">        scaled_base : bool, optional</span>
<span class="sd">            Whether the base was scaled the same way. This affects whether</span>
<span class="sd">            differential components should be scaled. For instance, a differential</span>
<span class="sd">            in longitude should not be scaled if its spherical base is scaled</span>
<span class="sd">            in radius.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaled_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">scaled_attrs</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If ``other`` is a representation,</span>
<span class="sd">        it will be used as a base for which to evaluate the differential,</span>
<span class="sd">        and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">self_cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">self_cartesian</span><span class="p">,</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># avoid &quot;differential - representation&quot;.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseRepresentation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="BaseDifferential.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseDifferential.html#astropy.coordinates.BaseDifferential.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector norm.</span>

<span class="sd">        The norm is the standard Frobenius norm, i.e., the square root of the</span>
<span class="sd">        sum of the squares of all components with non-angular units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined. This is</span>
<span class="sd">            required to calculate the physical size of the differential for</span>
<span class="sd">            all but Cartesian differentials or radial differentials.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `astropy.units.Quantity`</span>
<span class="sd">            Vector norm, with the same shape as the representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># RadialDifferential overrides this function, so there is no handling here</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CartesianDifferential</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`base` must be provided to calculate the norm of a&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CartesianDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential">[docs]</a><span class="k">class</span> <span class="nc">CartesianDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differentials in of points in 3D cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_x, d_y, d_z : `~astropy.units.Quantity` or array</span>
<span class="sd">        The x, y, and z coordinates of the differentials. If ``d_x``, ``d_y``,</span>
<span class="sd">        and ``d_z`` have different shapes, they should be broadcastable. If not</span>
<span class="sd">        quantities, ``unit`` should be set.  If only ``d_x`` is given, it is</span>
<span class="sd">        assumed that it contains an array with the 3 coordinates stored along</span>
<span class="sd">        ``xyz_axis``.</span>
<span class="sd">    unit : `~astropy.units.Unit` or str</span>
<span class="sd">        If given, the differentials will be converted to this unit (or taken to</span>
<span class="sd">        be in this unit if not given.</span>
<span class="sd">    xyz_axis : int, optional</span>
<span class="sd">        The axis along which the coordinates are stored when a single array is</span>
<span class="sd">        provided instead of distinct ``d_x``, ``d_y``, and ``d_z`` (default: 0).</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">CartesianRepresentation</span>
    <span class="n">_d_xyz</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">d_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">d_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d_x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;OV&#39;</span><span class="p">:</span>
                <span class="c1"># Short-cut for 3-D array input.</span>
                <span class="n">d_x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># Keep a link to the array with all three coordinates</span>
                <span class="c1"># so that we can return it quickly if needed in get_xyz.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d_xyz</span> <span class="o">=</span> <span class="n">d_x</span>
                <span class="k">if</span> <span class="n">xyz_axis</span><span class="p">:</span>
                    <span class="n">d_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">=</span> <span class="n">xyz_axis</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span> <span class="o">=</span> <span class="n">d_x</span>
                <span class="k">return</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_z</span> <span class="o">=</span> <span class="n">d_x</span>

        <span class="k">if</span> <span class="n">xyz_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xyz_axis should only be set if d_x, d_y, and d_z &quot;</span>
                             <span class="s2">&quot;are in a single array passed in through d_x, &quot;</span>
                             <span class="s2">&quot;i.e., d_y and d_z should not be not given.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">d_z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;d_x, d_y, and d_z are required to instantiate </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d_y</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_y</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d_z</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">(</span><span class="n">d_z</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_y</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="o">.</span><span class="n">unit</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_x, d_y and d_z should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="CartesianDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CartesianRepresentation</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span>
                                         <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">])</span></div>

<div class="viewcode-block" id="CartesianDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">])</span></div>

<div class="viewcode-block" id="CartesianDifferential.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed_base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform differentials using a 3x3 matrix in a Cartesian basis.</span>

<span class="sd">        This returns a new differential and does not modify the original one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 (or stack thereof) matrix, such as a rotation matrix.</span>
<span class="sd">        base, transformed_base : `~astropy.coordinates.CartesianRepresentation` or None, optional</span>
<span class="sd">            Not used in the Cartesian transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># erfa rxp: Multiply a p-vector by an r-matrix.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">erfa_ufunc</span><span class="o">.</span><span class="n">rxp</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_d_xyz</span><span class="p">(</span><span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CartesianDifferential.get_d_xyz"><a class="viewcode-back" href="../../../api/astropy.coordinates.CartesianDifferential.html#astropy.coordinates.CartesianDifferential.get_d_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">get_d_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a vector array of the x, y, and z coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_axis : int, optional</span>
<span class="sd">            The axis in the final array along which the x, y, z components</span>
<span class="sd">            should be stored (default: 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        d_xyz : `~astropy.units.Quantity`</span>
<span class="sd">            With dimension 3 along ``xyz_axis``.  Note that, if possible,</span>
<span class="sd">            this will be a view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span> <span class="o">==</span> <span class="n">xyz_axis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_xyz</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xyz_axis</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="p">)</span>

        <span class="c1"># Create combined array.  TO DO: keep it in _d_xyz for repeated use?</span>
        <span class="c1"># But then in-place changes have to cancel it. Likely best to</span>
        <span class="c1"># also update components.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">xyz_axis</span><span class="p">)</span></div>

    <span class="n">d_xyz</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_d_xyz</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseSphericalDifferential.html#astropy.coordinates.BaseSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseSphericalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_d_lon_coslat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon to d_lon_coslat.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_d_lon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon_coslat to d_lon.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d_lon_coslat : `~astropy.units.Quantity`</span>
<span class="sd">            Longitude differential that includes ``cos(lat)``.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If both are different parts of</span>
<span class="sd">        a `~astropy.coordinates.SphericalDifferential` (e.g., a</span>
<span class="sd">        `~astropy.coordinates.UnitSphericalDifferential` and a</span>
<span class="sd">        `~astropy.coordinates.RadialDifferential`), they will combined</span>
<span class="sd">        appropriately.</span>

<span class="sd">        If ``other`` is a representation, it will be used as a base for which</span>
<span class="sd">        to evaluate the differential, and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseSphericalDifferential</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="UnitSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalDifferential</span><span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The longitude and latitude of the differentials.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_differential</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalDifferential</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon and d_lat should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># Go via the dimensional equivalent, so that the longitude and latitude</span>
        <span class="c1"># differentials correctly take into account the norm of the base.</span>
        <span class="n">dimensional</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_dimensional_differential</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dimensional</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">distance</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Only have enough information to represent other unit-spherical.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalCosLatDifferential</span><span class="p">,</span>
                                         <span class="n">UnitSphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="n">d_lon</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalDifferential.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalDifferential.html#astropy.coordinates.UnitSphericalDifferential.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform differential using a 3x3 matrix in a Cartesian basis.</span>

<span class="sd">        This returns a new differential and does not modify the original one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 (or stack thereof) matrix, such as a rotation matrix.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined.  If the other</span>
<span class="sd">            class is a differential representation, the base will be converted</span>
<span class="sd">            to its ``base_representation``.</span>
<span class="sd">        transformed_base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the transformed differentials are defined.</span>
<span class="sd">            If the other class is a differential representation, the base will</span>
<span class="sd">            be converted to its ``base_representation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the transformation matrix does not need to be a rotation matrix,</span>
        <span class="c1"># so the unit-distance is not guaranteed. For speed, we check if the</span>
        <span class="c1"># matrix is in O(3) and preserves lengths.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_O3</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>  <span class="c1"># remain in unit-rep</span>
            <span class="c1"># TODO! implement without Cartesian intermediate step.</span>
            <span class="c1"># some of this can be moved to the parent class.</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># switch to dimensional representation</span>
            <span class="n">du</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">base</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># derivative unit</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_differential</span><span class="p">(</span>
                <span class="n">d_lon</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">du</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diff</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scaled_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">SphericalDifferential</span><span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The differential longitude and latitude.</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">SphericalRepresentation</span>
    <span class="n">_unit_differential</span> <span class="o">=</span> <span class="n">UnitSphericalDifferential</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon and d_lat should have equivalent units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalDifferential.html#astropy.coordinates.SphericalDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="n">d_lon</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scaled_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="BaseSphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.BaseSphericalCosLatDifferential.html#astropy.coordinates.BaseSphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">BaseSphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differentials from points on a spherical base representation.</span>

<span class="sd">    With cos(lat) assumed to be included in the longitude differential.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_base_vectors</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get unit vectors and scale factors from (unit)spherical base.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``self.base_representation``</span>
<span class="sd">            The points for which the unit vectors and scale factors should be</span>
<span class="sd">            retrieved.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unit_vectors : dict of `CartesianRepresentation`</span>
<span class="sd">            In the directions of the coordinates of base.</span>
<span class="sd">        scale_factors : dict of `~astropy.units.Quantity`</span>
<span class="sd">            Scale factors for each of the coordinates.  The scale factor for</span>
<span class="sd">            longitude does not include the cos(lat) factor.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError : if the base is not of the correct type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">unit_vectors</span><span class="p">(),</span> <span class="n">base</span><span class="o">.</span><span class="n">scale_factors</span><span class="p">(</span><span class="n">omit_coslat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_d_lon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential with cos(lat) to one without.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_d_lon_coslat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert longitude differential d_lon to d_lon_coslat.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        d_lon : `~astropy.units.Quantity`</span>
<span class="sd">            Value of the longitude differential without ``cos(lat)``.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            The base from which the latitude will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d_lon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine two differentials, or a differential with a representation.</span>

<span class="sd">        If ``other`` is of the same differential type as ``self``, the</span>
<span class="sd">        components will simply be combined.  If both are different parts of</span>
<span class="sd">        a `~astropy.coordinates.SphericalDifferential` (e.g., a</span>
<span class="sd">        `~astropy.coordinates.UnitSphericalDifferential` and a</span>
<span class="sd">        `~astropy.coordinates.RadialDifferential`), they will combined</span>
<span class="sd">        appropriately.</span>

<span class="sd">        If ``other`` is a representation, it will be used as a base for which</span>
<span class="sd">        to evaluate the differential, and the result is a new representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op : `~operator` callable</span>
<span class="sd">            Operator to apply (e.g., `~operator.add`, `~operator.sub`, etc.</span>
<span class="sd">        other : `~astropy.coordinates.BaseRepresentation` subclass instance</span>
<span class="sd">            The other differential or representation.</span>
<span class="sd">        reverse : bool</span>
<span class="sd">            Whether the operands should be reversed (e.g., as we got here via</span>
<span class="sd">            ``self.__rsub__`` because ``self`` is a subclass of ``other``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseSphericalCosLatDifferential</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalCosLatDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="UnitSphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">UnitSphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseSphericalCosLatDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points on a unit sphere.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon_coslat, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The longitude and latitude of the differentials.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">UnitSphericalRepresentation</span>
    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d_lon_coslat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;d_lat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">_dimensional_differential</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SphericalCosLatDifferential</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon_coslat and d_lat should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="c1"># Go via the dimensional equivalent, so that the longitude and latitude</span>
        <span class="c1"># differentials correctly take into account the norm of the base.</span>
        <span class="n">dimensional</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_dimensional_differential</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dimensional</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">distance</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PhysicsSphericalRepresentation</span><span class="p">):</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scale</span> <span class="o">*</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Only have enough information to represent other unit-spherical.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though w/o CosLat needs base for the latitude.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                                         <span class="n">UnitSphericalDifferential</span><span class="p">)):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnitSphericalCosLatDifferential.transform"><a class="viewcode-back" href="../../../api/astropy.coordinates.UnitSphericalCosLatDifferential.html#astropy.coordinates.UnitSphericalCosLatDifferential.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform differential using a 3x3 matrix in a Cartesian basis.</span>

<span class="sd">        This returns a new differential and does not modify the original one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : (3,3) array-like</span>
<span class="sd">            A 3x3 (or stack thereof) matrix, such as a rotation matrix.</span>
<span class="sd">        base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the differentials are defined.  If the other</span>
<span class="sd">            class is a differential representation, the base will be converted</span>
<span class="sd">            to its ``base_representation``.</span>
<span class="sd">        transformed_base : instance of ``cls.base_representation``</span>
<span class="sd">            Base relative to which the transformed differentials are defined.</span>
<span class="sd">            If the other class is a differential representation, the base will</span>
<span class="sd">            be converted to its ``base_representation``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the transformation matrix does not need to be a rotation matrix,</span>
        <span class="c1"># so the unit-distance is not guaranteed. For speed, we check if the</span>
        <span class="c1"># matrix is in O(3) and preserves lengths.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_O3</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>  <span class="c1"># remain in unit-rep</span>
            <span class="c1"># TODO! implement without Cartesian intermediate step.</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># switch to dimensional representation</span>
            <span class="n">du</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="o">.</span><span class="n">unit</span> <span class="o">/</span> <span class="n">base</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">unit</span>  <span class="c1"># derivative unit</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensional_differential</span><span class="p">(</span>
                <span class="n">d_lon_coslat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                <span class="n">d_distance</span><span class="o">=</span><span class="mi">0</span> <span class="o">*</span> <span class="n">du</span>
            <span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">transformed_base</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diff</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scaled_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="SphericalCosLatDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential">[docs]</a><span class="k">class</span> <span class="nc">SphericalCosLatDifferential</span><span class="p">(</span><span class="n">BaseSphericalCosLatDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in 3D spherical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_lon_coslat, d_lat : `~astropy.units.Quantity`</span>
<span class="sd">        The differential longitude (with cos(lat) included) and latitude.</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">SphericalRepresentation</span>
    <span class="n">_unit_differential</span> <span class="o">=</span> <span class="n">UnitSphericalCosLatDifferential</span>
    <span class="n">attr_classes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;d_lon_coslat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;d_lat&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">,</span>
                    <span class="s1">&#39;d_distance&#39;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">d_lat</span><span class="p">,</span> <span class="n">d_distance</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_lon_coslat</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lat</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_lon_coslat and d_lat should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SphericalCosLatDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though some need base for the latitude to remove cos(lat).</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_lon</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="SphericalCosLatDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.SphericalCosLatDifferential.html#astropy.coordinates.SphericalCosLatDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though we need base for the latitude to remove coslat.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_get_d_lon_coslat</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scaled_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="RadialDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential">[docs]</a><span class="k">class</span> <span class="nc">RadialDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of radial distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_distance : `~astropy.units.Quantity`</span>
<span class="sd">        The differential distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">RadialRepresentation</span>

<div class="viewcode-block" id="RadialDifferential.to_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.to_cartesian">[docs]</a>    <span class="k">def</span> <span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span> <span class="o">*</span> <span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span>
            <span class="n">UnitSphericalRepresentation</span><span class="p">)</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">()</span></div>

<div class="viewcode-block" id="RadialDifferential.norm"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span></div>

<div class="viewcode-block" id="RadialDifferential.from_cartesian"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.from_cartesian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_cartesian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">UnitSphericalRepresentation</span><span class="p">)),</span>
                   <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="RadialDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.RadialDifferential.html#astropy.coordinates.RadialDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="p">(</span><span class="n">SphericalDifferential</span><span class="p">,</span>
                                       <span class="n">SphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">PhysicsSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_combine_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_representation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">distance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_distance</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">distance</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseSphericalDifferential</span><span class="p">,</span>
                                <span class="n">BaseSphericalCosLatDifferential</span><span class="p">)):</span>
            <span class="n">all_components</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
            <span class="n">first</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_components</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">SphericalDifferential</span><span class="p">(</span><span class="o">**</span><span class="n">result_args</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_combine_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">reverse</span><span class="p">)</span></div>


<div class="viewcode-block" id="PhysicsSphericalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential">[docs]</a><span class="k">class</span> <span class="nc">PhysicsSphericalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of 3D spherical coordinates using physics convention.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_phi, d_theta : `~astropy.units.Quantity`</span>
<span class="sd">        The differential azimuth and inclination.</span>
<span class="sd">    d_r : `~astropy.units.Quantity`</span>
<span class="sd">        The differential radial distance.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">PhysicsSphericalRepresentation</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_phi</span><span class="p">,</span> <span class="n">d_theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_r</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_phi</span><span class="p">,</span> <span class="n">d_theta</span><span class="p">,</span> <span class="n">d_r</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_phi</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_theta</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s1">&#39;d_phi and d_theta should have equivalent &#39;</span>
                               <span class="s1">&#39;units.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="PhysicsSphericalDifferential.represent_as"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential.represent_as">[docs]</a>    <span class="k">def</span> <span class="nf">represent_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># All spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though CosLat needs base for the latitude. For those, explicitly</span>
        <span class="c1"># do the equivalent of self._d_lon_coslat in SphericalDifferential.</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">UnitSphericalCosLatDifferential</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_lon_coslat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="n">d_lon_coslat</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">RadialDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">represent_as</span><span class="p">(</span><span class="n">other_class</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhysicsSphericalDifferential.from_representation"><a class="viewcode-back" href="../../../api/astropy.coordinates.PhysicsSphericalDifferential.html#astropy.coordinates.PhysicsSphericalDifferential.from_representation">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_representation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Other spherical differentials can be done without going to Cartesian,</span>
        <span class="c1"># though we need base for the latitude to remove coslat. For that case,</span>
        <span class="c1"># do the equivalent of cls._d_lon in SphericalDifferential.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalDifferential</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lon</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span>
                       <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">SphericalCosLatDifferential</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_check_base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">d_phi</span> <span class="o">=</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_lon_coslat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d_phi</span><span class="p">,</span> <span class="o">-</span><span class="n">representation</span><span class="o">.</span><span class="n">d_lat</span><span class="p">,</span> <span class="n">representation</span><span class="o">.</span><span class="n">d_distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">from_representation</span><span class="p">(</span><span class="n">representation</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">scaled_base</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scaled_base</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_theta</span><span class="p">,</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_scale_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="CylindricalDifferential"><a class="viewcode-back" href="../../../api/astropy.coordinates.CylindricalDifferential.html#astropy.coordinates.CylindricalDifferential">[docs]</a><span class="k">class</span> <span class="nc">CylindricalDifferential</span><span class="p">(</span><span class="n">BaseDifferential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Differential(s) of points in cylindrical coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d_rho : `~astropy.units.Quantity` [&#39;speed&#39;]</span>
<span class="sd">        The differential cylindrical radius.</span>
<span class="sd">    d_phi : `~astropy.units.Quantity` [&#39;angular speed&#39;]</span>
<span class="sd">        The differential azimuth.</span>
<span class="sd">    d_z : `~astropy.units.Quantity` [&#39;speed&#39;]</span>
<span class="sd">        The differential height.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If `True` (default), arrays will be copied. If `False`, arrays will</span>
<span class="sd">        be references, though possibly broadcast to ensure matching shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_representation</span> <span class="o">=</span> <span class="n">CylindricalRepresentation</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_rho</span><span class="p">,</span> <span class="n">d_phi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d_z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d_rho</span><span class="p">,</span> <span class="n">d_phi</span><span class="p">,</span> <span class="n">d_z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_d_rho</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_d_z</span><span class="o">.</span><span class="n">unit</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;d_rho and d_z should have equivalent units.&quot;</span><span class="p">)</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011–2022, The Astropy Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.4. &nbsp;
    Last built 09 May 2022. <br/>
  </p>
</footer>
  </body>
</html>