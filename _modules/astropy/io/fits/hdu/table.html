


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>astropy.io.fits.hdu.table &#8212; Astropy v5.2.dev94+gb1133d712.d20220509</title>
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-rendered-html.css" />
    
    <script id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/astropy_logo.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
  
  <meta name="robots" content="noindex, nofollow">
  
  
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>


  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">Astropy v5.2.dev94+gb1133d712.d20220509</a>
	 &#187;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.hdu.table</h1><div class="highlight"><pre>
<span></span><span class="c1"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>


<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">char</span> <span class="k">as</span> <span class="n">chararray</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">DELAYED</span><span class="p">,</span> <span class="n">_ValidHDU</span><span class="p">,</span> <span class="n">ExtensionHDU</span>
<span class="c1"># This module may have many dependencies on astropy.io.fits.column, but</span>
<span class="c1"># astropy.io.fits.column has fewer dependencies overall, so it&#39;s easier to</span>
<span class="c1"># keep table/column-related utilities in astropy.io.fits.column</span>
<span class="kn">from</span> <span class="nn">astropy.io.fits.column</span> <span class="kn">import</span> <span class="p">(</span><span class="n">FITS2NUMPY</span><span class="p">,</span> <span class="n">KEYWORD_NAMES</span><span class="p">,</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">,</span>
                      <span class="n">ATTRIBUTE_TO_KEYWORD</span><span class="p">,</span> <span class="n">TDEF_RE</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">,</span>
                      <span class="n">_AsciiColDefs</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">,</span> <span class="n">_FormatQ</span><span class="p">,</span> <span class="n">_makep</span><span class="p">,</span>
                      <span class="n">_parse_tformat</span><span class="p">,</span> <span class="n">_scalar_to_format</span><span class="p">,</span> <span class="n">_convert_format</span><span class="p">,</span>
                      <span class="n">_cmp_recformats</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">astropy.io.fits.fitsrec</span> <span class="kn">import</span> <span class="n">FITS_rec</span><span class="p">,</span> <span class="n">_get_recarray_field</span><span class="p">,</span> <span class="n">_has_unicode_fields</span>
<span class="kn">from</span> <span class="nn">astropy.io.fits.header</span> <span class="kn">import</span> <span class="n">Header</span><span class="p">,</span> <span class="n">_pad_length</span>
<span class="kn">from</span> <span class="nn">astropy.io.fits.util</span> <span class="kn">import</span> <span class="n">_is_int</span><span class="p">,</span> <span class="n">_str_to_num</span>

<span class="kn">from</span> <span class="nn">astropy.utils</span> <span class="kn">import</span> <span class="n">lazyproperty</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyDeprecationWarning</span>


<span class="k">class</span> <span class="nc">FITSTableDumpDialect</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">excel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CSV dialect for the Astropy format of ASCII dumps of FITS tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>
    <span class="n">lineterminator</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">quotechar</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="n">quoting</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_ALL</span>
    <span class="n">skipinitialspace</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">_TableLikeHDU</span><span class="p">(</span><span class="n">_ValidHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for HDUs that have table-like data.  This is used for both</span>
<span class="sd">    Binary/ASCII tables as well as Random Access Group HDUs (which are</span>
<span class="sd">    otherwise too dissimilar for tables to use _TableBaseHDU directly).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_data_type</span> <span class="o">=</span> <span class="n">FITS_rec</span>
    <span class="n">_columns_type</span> <span class="o">=</span> <span class="n">ColDefs</span>

    <span class="c1"># TODO: Temporary flag representing whether uints are enabled; remove this</span>
    <span class="c1"># after restructuring to support uints by default on a per-column basis</span>
    <span class="n">_uint</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an abstract HDU type for HDUs that contain table-like data.</span>
<span class="sd">        This is even more abstract than _TableBaseHDU which is specifically for</span>
<span class="sd">        the standard ASCII and Binary Table types.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_columns</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">character_as_bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given either a `ColDefs` object, a sequence of `Column` objects,</span>
<span class="sd">        or another table HDU or table data (a `FITS_rec` or multi-field</span>
<span class="sd">        `numpy.ndarray` or `numpy.recarray` object, return a new table HDU of</span>
<span class="sd">        the class this method was called on using the column definition from</span>
<span class="sd">        the input.</span>

<span class="sd">        See also `FITS_rec.from_columns`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns : sequence of `Column`, `ColDefs` -like</span>
<span class="sd">            The columns from which to create the table data, or an object with</span>
<span class="sd">            a column-like structure from which a `ColDefs` can be instantiated.</span>
<span class="sd">            This includes an existing `BinTableHDU` or `TableHDU`, or a</span>
<span class="sd">            `numpy.recarray` to give some examples.</span>

<span class="sd">            If these columns have data arrays attached that data may be used in</span>
<span class="sd">            initializing the new table.  Otherwise the input columns will be</span>
<span class="sd">            used as a template for a new table with the requested number of</span>
<span class="sd">            rows.</span>

<span class="sd">        header : `Header`</span>
<span class="sd">            An optional `Header` object to instantiate the new HDU yet.  Header</span>
<span class="sd">            keywords specifically related to defining the table structure (such</span>
<span class="sd">            as the &quot;TXXXn&quot; keywords like TTYPEn) will be overridden by the</span>
<span class="sd">            supplied column definitions, but all other informational and data</span>
<span class="sd">            model-specific keywords are kept.</span>

<span class="sd">        nrows : int</span>
<span class="sd">            Number of rows in the new table.  If the input columns have data</span>
<span class="sd">            associated with them, the size of the largest input column is used.</span>
<span class="sd">            Otherwise the default is 0.</span>

<span class="sd">        fill : bool</span>
<span class="sd">            If `True`, will fill all cells with zeros or blanks.  If `False`,</span>
<span class="sd">            copy the data from input, undefined cells will still be filled with</span>
<span class="sd">            zeros/blanks.</span>

<span class="sd">        character_as_bytes : bool</span>
<span class="sd">            Whether to return bytes for string columns when accessed from the</span>
<span class="sd">            HDU. By default this is `False` and (unicode) strings are returned,</span>
<span class="sd">            but for large tables this may use up a lot of memory.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Any additional keyword arguments accepted by the HDU class&#39;s</span>
<span class="sd">        ``__init__`` may also be passed in as keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coldefs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">coldefs</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span>
                                     <span class="n">character_as_bytes</span><span class="o">=</span><span class="n">character_as_bytes</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">character_as_bytes</span><span class="o">=</span><span class="n">character_as_bytes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">coldefs</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="n">hdu</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdu</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`ColDefs` objects describing the columns in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The base class doesn&#39;t make any assumptions about where the column</span>
        <span class="c1"># definitions come from, so just return an empty ColDefs</span>
        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">([])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        table-like HDUs must provide an attribute that specifies the number of</span>
<span class="sd">        rows in the HDU&#39;s table.</span>

<span class="sd">        For now this is an internal-only attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_get_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the table data from an input HDU object.&quot;&quot;&quot;</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

        <span class="c1"># TODO: Details related to variable length arrays need to be dealt with</span>
        <span class="c1"># specifically in the BinTableHDU class, since they&#39;re a detail</span>
        <span class="c1"># specific to FITS binary tables</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_FormatP</span><span class="p">,</span> <span class="n">_FormatQ</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span><span class="p">):</span>
            <span class="c1"># We have a heap; include it in the raw_data</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
            <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:</span><span class="n">tbsize</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                          <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raw_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This can happen when a brand new table HDU is being created</span>
                <span class="c1"># and no data has been assigned to the columns, which case just</span>
                <span class="c1"># return an empty array</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_tbdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_init_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

        <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>

        <span class="c1"># hack to enable pseudo-uint support</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span>

        <span class="c1"># pass datLoc, for P format</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_heapoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;PCOUNT&#39;</span><span class="p">]</span>
        <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span> <span class="o">-</span> <span class="n">tbsize</span>

        <span class="c1"># pass the attributes</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="c1"># get the data for each column object from the rec.recarray</span>
            <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># delete the _arrays attribute so that it is recreated to point to the</span>
        <span class="c1"># new data placed in the column object above</span>
        <span class="k">del</span> <span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>

    <span class="k">def</span> <span class="nf">_update_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data if asked to.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_update_column_added</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the data upon addition of a new column through the `ColDefs`</span>
<span class="sd">        interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># recreate data from the columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">character_as_bytes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_character_as_bytes</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the data upon removal of a column through the `ColDefs`</span>
<span class="sd">        interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># recreate data from the columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">character_as_bytes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_character_as_bytes</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">_TableBaseHDU</span><span class="p">(</span><span class="n">ExtensionHDU</span><span class="p">,</span> <span class="n">_TableLikeHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS table extension base HDU class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array</span>
<span class="sd">        Data to be used.</span>
<span class="sd">    header : `Header` instance</span>
<span class="sd">        Header to be used. If the ``data`` is also specified, header keywords</span>
<span class="sd">        specifically related to defining the table structure (such as the</span>
<span class="sd">        &quot;TXXXn&quot; keywords like TTYPEn) will be overridden by the supplied column</span>
<span class="sd">        definitions, but all other informational and data model-specific</span>
<span class="sd">        keywords are kept.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name to be populated in ``EXTNAME`` keyword.</span>
<span class="sd">    uint : bool, optional</span>
<span class="sd">        Set to `True` if the table contains unsigned integer columns.</span>
<span class="sd">    ver : int &gt; 0 or None, optional</span>
<span class="sd">        The ver of the HDU, will be the value of the keyword ``EXTVER``.</span>
<span class="sd">        If not given or None, it defaults to the value of the ``EXTVER``</span>
<span class="sd">        card of the ``header`` or 1.</span>
<span class="sd">        (default: None)</span>
<span class="sd">    character_as_bytes : bool</span>
<span class="sd">        Whether to return bytes for string columns. By default this is `False`</span>
<span class="sd">        and (unicode) strings are returned, but this does not respect memory</span>
<span class="sd">        mapping and loads the whole column in memory when accessed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_manages_own_heap</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This flag implies that when writing VLA tables (P/Q format) the heap</span>
<span class="sd">    pointers that go into P/Q table columns should not be reordered or</span>
<span class="sd">    rearranged in any way by the default heap management code.</span>

<span class="sd">    This is included primarily as an optimization for compressed image HDUs</span>
<span class="sd">    which perform their own heap maintenance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">character_as_bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="n">ver</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="n">uint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_character_as_bytes</span> <span class="o">=</span> <span class="n">character_as_bytes</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">DELAYED</span><span class="p">:</span>
            <span class="c1"># this should never happen</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No header to setup HDU.&#39;</span><span class="p">)</span>

            <span class="c1"># if the file is read the first time, no need to copy, and keep it</span>
            <span class="c1"># unchanged</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># construct a list of cards of minimal header</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;XTENSION&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ext_comment</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;array data type&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;number of array dimensions&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;length of dimension 1&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;length of dimension 2&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;number of group parameters&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;number of groups&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;number of table fields&#39;</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># Make a &quot;copy&quot; (not just a view) of the input header, since it</span>
                <span class="c1"># may get modified.  the data is still a &quot;view&quot; (for now)</span>
                <span class="n">hcopy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">strip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">hcopy</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># self._data_type is FITS_rec.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="c1"># TEMP: Special column keywords are normally overwritten by attributes</span>
                <span class="c1"># from Column objects. In Astropy 3.0, several new keywords are now</span>
                <span class="c1"># recognized as being special column keywords, but we don&#39;t</span>
                <span class="c1"># automatically clear them yet, as we need to raise a deprecation</span>
                <span class="c1"># warning for at least one major version.</span>
                <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">future_ignore</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">TDEF_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">base_keyword</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="k">continue</span>                <span class="c1"># skip if there is no match</span>
                        <span class="k">if</span> <span class="n">base_keyword</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;TCTYP&#39;</span><span class="p">,</span> <span class="s1">&#39;TCUNI&#39;</span><span class="p">,</span> <span class="s1">&#39;TCRPX&#39;</span><span class="p">,</span> <span class="s1">&#39;TCRVL&#39;</span><span class="p">,</span> <span class="s1">&#39;TCDLT&#39;</span><span class="p">,</span> <span class="s1">&#39;TRPOS&#39;</span><span class="p">}:</span>
                            <span class="n">future_ignore</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base_keyword</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">future_ignore</span><span class="p">:</span>
                        <span class="n">keys</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;n&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">future_ignore</span><span class="p">))</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The following keywords are now recognized as special &quot;</span>
                                      <span class="s2">&quot;column-related attributes and should be set via the &quot;</span>
                                      <span class="s2">&quot;Column objects: </span><span class="si">{}</span><span class="s2">. In future, these values will be &quot;</span>
                                      <span class="s2">&quot;dropped from manually specified headers automatically &quot;</span>
                                      <span class="s2">&quot;and replaced with values generated based on the &quot;</span>
                                      <span class="s2">&quot;Column objects.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

                <span class="c1"># TODO: Too much of the code in this class uses header keywords</span>
                <span class="c1"># in making calculations related to the data size.  This is</span>
                <span class="c1"># unreliable, however, in cases when users mess with the header</span>
                <span class="c1"># unintentionally--code that does this should be cleaned up.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

                <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                    <span class="c1"># Make the ndarrays in the Column objects of the ColDefs</span>
                    <span class="c1"># object of the HDU reference the same ndarray as the HDU&#39;s</span>
                    <span class="c1"># FITS_rec object.</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                        <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="c1"># Delete the _arrays attribute so that it is recreated to</span>
                    <span class="c1"># point to the new data placed in the column objects above</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>
            <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Table data has incorrect type.&#39;</span><span class="p">)</span>

        <span class="c1"># Ensure that the correct EXTNAME is set on the new header if one was</span>
        <span class="c1"># created, or that it overrides the existing EXTNAME if different</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">ver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ver</span> <span class="o">=</span> <span class="n">ver</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an abstract type that implements the shared functionality of</span>
<span class="sd">        the ASCII and Binary Table HDU types, which should be used instead of</span>
<span class="sd">        this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`ColDefs` objects describing the columns in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_coldefs&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tbdata</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_character_as_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character_as_bytes</span>
        <span class="c1"># Columns should now just return a reference to the data._coldefs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Create a new table with the same columns, but empty rows</span>
            <span class="n">formats</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="n">formats</span><span class="p">,</span>
                                <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
                                <span class="n">shape</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Go ahead and always make a view, even if the data is already the</span>
            <span class="c1"># correct class (self._data_type) so we can update things like the</span>
            <span class="c1"># column defs, if necessary</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">):</span>
                <span class="c1"># This would be the place, if the input data was for an ASCII</span>
                <span class="c1"># table and this is binary table, or vice versa, to convert the</span>
                <span class="c1"># data to the appropriate format for the table type</span>
                <span class="n">new_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">new_columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_remove_listener</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c1"># Make the ndarrays in the Column objects of the ColDefs</span>
                <span class="c1"># object of the HDU reference the same ndarray as the HDU&#39;s</span>
                <span class="c1"># FITS_rec object.</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># Delete the _arrays attribute so that it is recreated to</span>
                <span class="c1"># point to the new data placed in the column objects above</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Table data has incorrect type.&#39;</span><span class="p">)</span>

        <span class="c1"># returning the data signals to lazyproperty that we&#39;ve already handled</span>
        <span class="c1"># setting self.__dict__[&#39;data&#39;]</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_theap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;THEAP&#39;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="c1"># TODO: Need to either rename this to update_header, for symmetry with the</span>
    <span class="c1"># Image HDUs, or just at some point deprecate it and remove it altogether,</span>
    <span class="c1"># since header updates should occur automatically when necessary...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update header keywords to reflect recent changes of columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">after</span><span class="o">=</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">after</span><span class="o">=</span><span class="s1">&#39;GCOUNT&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_table_keywords</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_table_keywords</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the table HDU, both header and data are copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># touch the data, so it&#39;s defined (in the case of reading from a</span>
        <span class="c1"># FITS file)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_prewriteto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_scale_back</span><span class="p">(</span>
                <span class="n">update_heap_pointers</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manages_own_heap</span><span class="p">)</span>
            <span class="c1"># check TFIELDS and NAXIS2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># calculate PCOUNT, for variable length tables</span>
            <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">heapstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;THEAP&#39;</span><span class="p">,</span> <span class="n">tbsize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">=</span> <span class="n">heapstart</span> <span class="o">-</span> <span class="n">tbsize</span>
            <span class="n">pcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span>
            <span class="k">if</span> <span class="n">pcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;PCOUNT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcount</span>

            <span class="c1"># update the other T****n keywords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populate_table_keywords</span><span class="p">()</span>

            <span class="c1"># update TFORM for variable length columns</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
                    <span class="n">_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                    <span class="c1"># May be either _FormatP or _FormatQ</span>
                    <span class="n">format_cls</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="vm">__class__</span>
                    <span class="nb">format</span> <span class="o">=</span> <span class="n">format_cls</span><span class="p">(</span><span class="nb">format</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">format</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span>
                                        <span class="nb">max</span><span class="o">=</span><span class="n">_max</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">tform</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_prewriteto</span><span class="p">(</span><span class="n">checksum</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _TableBaseHDU verify method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">):</span>

                <span class="n">err_text</span> <span class="o">=</span> <span class="s1">&#39;The XTENSION keyword must match the HDU type.&#39;</span>
                <span class="n">fix_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Converted the XTENSION keyword to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="si">}</span><span class="s1">.&#39;</span>

                <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">):</span>
                    <span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ext_comment</span><span class="p">)</span>

                <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                                            <span class="n">fix_text</span><span class="o">=</span><span class="n">fix_text</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
                           <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">999</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                           <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
            <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                               <span class="n">errs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errs</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the HDU: name, dimensions, and formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># if data is touched, use data info.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">formats</span>

        <span class="c1"># if data is not touched yet, use header info.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">)])</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;[</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s1">]&#39;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nrows</span><span class="si">}</span><span class="s2">R x </span><span class="si">{</span><span class="n">ncols</span><span class="si">}</span><span class="s2">C&quot;</span>
        <span class="n">ncards</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ver</span><span class="p">,</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">ncards</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_update_column_removed</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Fix the header to reflect the column removal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_table_keywords</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_attribute_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span>
                                         <span class="n">old_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the header when one of the column objects is updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># base_keyword is the keyword without the index such as TDIM</span>
        <span class="c1"># while keyword is like TDIM1</span>
        <span class="n">base_keyword</span> <span class="o">=</span> <span class="n">ATTRIBUTE_TO_KEYWORD</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">base_keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If the new value is None, i.e. None was assigned to the</span>
                <span class="c1"># column attribute, then treat this as equivalent to deleting</span>
                <span class="c1"># that attribute</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyword_idx</span> <span class="o">=</span> <span class="n">KEYWORD_NAMES</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">base_keyword</span><span class="p">)</span>
            <span class="c1"># Determine the appropriate keyword to insert this one before/after</span>
            <span class="c1"># if it did not already exist in the header</span>
            <span class="k">for</span> <span class="n">before_keyword</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">KEYWORD_NAMES</span><span class="p">[:</span><span class="n">keyword_idx</span><span class="p">]):</span>
                <span class="n">before_keyword</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">before_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">before_keyword</span><span class="p">,</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_value</span><span class="p">),</span>
                                        <span class="n">after</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">after_keyword</span> <span class="ow">in</span> <span class="n">KEYWORD_NAMES</span><span class="p">[</span><span class="n">keyword_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">after_keyword</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">after_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">after_keyword</span><span class="p">,</span>
                                            <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_value</span><span class="p">))</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Just append</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="nf">_clear_table_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wipe out any existing table definition keywords from the header.</span>

<span class="sd">        If specified, only clear keywords for the given table index (shifting</span>
<span class="sd">        up keywords for any other columns).  The index is zero-based.</span>
<span class="sd">        Otherwise keywords for all columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First collect all the table structure related keyword in the header</span>
        <span class="c1"># into a single list so we can then sort them by index, which will be</span>
        <span class="c1"># useful later for updating the header in a sensible order (since the</span>
        <span class="c1"># header *might* not already be written in a reasonable order)</span>
        <span class="n">table_keywords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">TDEF_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">base_keyword</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>                <span class="c1"># skip if there is no match</span>

            <span class="k">if</span> <span class="n">base_keyword</span> <span class="ow">in</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">:</span>

                <span class="c1"># TEMP: For Astropy 3.0 we don&#39;t clear away the following keywords</span>
                <span class="c1"># as we are first raising a deprecation warning that these will be</span>
                <span class="c1"># dropped automatically if they were specified in the header. We</span>
                <span class="c1"># can remove this once we are happy to break backward-compatibility</span>
                <span class="k">if</span> <span class="n">base_keyword</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;TCTYP&#39;</span><span class="p">,</span> <span class="s1">&#39;TCUNI&#39;</span><span class="p">,</span> <span class="s1">&#39;TCRPX&#39;</span><span class="p">,</span> <span class="s1">&#39;TCRVL&#39;</span><span class="p">,</span> <span class="s1">&#39;TCDLT&#39;</span><span class="p">,</span> <span class="s1">&#39;TRPOS&#39;</span><span class="p">}:</span>
                    <span class="k">continue</span>

                <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># convert to zero-base</span>
                <span class="n">table_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">base_keyword</span><span class="p">,</span>
                                       <span class="n">num</span><span class="p">))</span>

        <span class="c1"># First delete</span>
        <span class="n">rev_sorted_idx_0</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table_keywords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                  <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">rev_sorted_idx_0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Now shift up remaining column keywords if only one column was cleared</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sorted_idx_3</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table_keywords</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">base_keyword</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">sorted_idx_3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">old_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
                <span class="n">new_card</span> <span class="o">=</span> <span class="p">(</span><span class="n">base_keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">old_card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                            <span class="n">old_card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_card</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

            <span class="c1"># Also decrement TFIELDS</span>
            <span class="k">if</span> <span class="s1">&#39;TFIELDS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_populate_table_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate the new table definition keywords from the header.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>


<div class="viewcode-block" id="TableHDU"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.TableHDU">[docs]</a><span class="k">class</span> <span class="nc">TableHDU</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS ASCII table extension HDU class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array or `FITS_rec`</span>
<span class="sd">        Data to be used.</span>
<span class="sd">    header : `Header`</span>
<span class="sd">        Header to be used.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name to be populated in ``EXTNAME`` keyword.</span>
<span class="sd">    ver : int &gt; 0 or None, optional</span>
<span class="sd">        The ver of the HDU, will be the value of the keyword ``EXTVER``.</span>
<span class="sd">        If not given or None, it defaults to the value of the ``EXTVER``</span>
<span class="sd">        card of the ``header`` or 1.</span>
<span class="sd">        (default: None)</span>
<span class="sd">    character_as_bytes : bool</span>
<span class="sd">        Whether to return bytes for string columns. By default this is `False`</span>
<span class="sd">        and (unicode) strings are returned, but this does not respect memory</span>
<span class="sd">        mapping and loads the whole column in memory when accessed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_extension</span> <span class="o">=</span> <span class="s1">&#39;TABLE&#39;</span>
    <span class="n">_ext_comment</span> <span class="o">=</span> <span class="s1">&#39;ASCII table extension&#39;</span>

    <span class="n">_padding_byte</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>
    <span class="n">_columns_type</span> <span class="o">=</span> <span class="n">_AsciiColDefs</span>

    <span class="n">__format_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;(?P&lt;code&gt;[ADEFIJ])(?P&lt;width&gt;\d+)(?:\.(?P&lt;prec&gt;\d+))?&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">character_as_bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="n">ver</span><span class="p">,</span> <span class="n">character_as_bytes</span><span class="o">=</span><span class="n">character_as_bytes</span><span class="p">)</span>

<div class="viewcode-block" id="TableHDU.match_header"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.TableHDU.match_header">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;XTENSION&#39;</span> <span class="ow">and</span> <span class="n">xtension</span> <span class="o">==</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_extension</span></div>

    <span class="k">def</span> <span class="nf">_get_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">)]</span>

        <span class="c1"># determine if there are duplicate field names and if there</span>
        <span class="c1"># are throw an exception</span>
        <span class="n">dup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">find_duplicate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate field names: </span><span class="si">{</span><span class="n">dup</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: Determine if this extra logic is necessary--I feel like the</span>
        <span class="c1"># _AsciiColDefs class should be responsible for telling the table what</span>
        <span class="c1"># its dtype should be...</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">columns</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The last column is padded out to the value of NAXIS1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">itemsize</span><span class="p">:</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">itemsize</span><span class="p">)</span>
            <span class="n">dtype</span><span class="p">[</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_tbdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="c1"># We have the data to be used.</span>
            <span class="c1"># We need to pad the data to a block length before calculating</span>
            <span class="c1"># the datasum.</span>
            <span class="n">bytes_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">_pad_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bytes_array</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>

            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the case where the data has not been read from the file</span>
            <span class="c1"># yet.  We can handle that in a generic manner so we do it in the</span>
            <span class="c1"># base class.  The other possibility is that there is no data at</span>
            <span class="c1"># all.  This can also be handled in a generic manner.</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s1">&#39;warn&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `TableHDU` verify method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s1">&#39;TFIELDS&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s1">&#39;TBCOL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_is_int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                           <span class="n">errs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errs</span></div>


<div class="viewcode-block" id="BinTableHDU"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU">[docs]</a><span class="k">class</span> <span class="nc">BinTableHDU</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binary table HDU class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array, `FITS_rec`, or `~astropy.table.Table`</span>
<span class="sd">        Data to be used.</span>
<span class="sd">    header : `Header`</span>
<span class="sd">        Header to be used.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name to be populated in ``EXTNAME`` keyword.</span>
<span class="sd">    uint : bool, optional</span>
<span class="sd">        Set to `True` if the table contains unsigned integer columns.</span>
<span class="sd">    ver : int &gt; 0 or None, optional</span>
<span class="sd">        The ver of the HDU, will be the value of the keyword ``EXTVER``.</span>
<span class="sd">        If not given or None, it defaults to the value of the ``EXTVER``</span>
<span class="sd">        card of the ``header`` or 1.</span>
<span class="sd">        (default: None)</span>
<span class="sd">    character_as_bytes : bool</span>
<span class="sd">        Whether to return bytes for string columns. By default this is `False`</span>
<span class="sd">        and (unicode) strings are returned, but this does not respect memory</span>
<span class="sd">        mapping and loads the whole column in memory when accessed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_extension</span> <span class="o">=</span> <span class="s1">&#39;BINTABLE&#39;</span>
    <span class="n">_ext_comment</span> <span class="o">=</span> <span class="s1">&#39;binary table extension&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">character_as_bytes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Table</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">astropy.io.fits.convenience</span> <span class="kn">import</span> <span class="n">table_to_hdu</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">table_to_hdu</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">header</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">uint</span><span class="o">=</span><span class="n">uint</span><span class="p">,</span> <span class="n">ver</span><span class="o">=</span><span class="n">ver</span><span class="p">,</span>
                         <span class="n">character_as_bytes</span><span class="o">=</span><span class="n">character_as_bytes</span><span class="p">)</span>

<div class="viewcode-block" id="BinTableHDU.match_header"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.match_header">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;XTENSION&#39;</span> <span class="ow">and</span>
                <span class="n">xtension</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_extension</span><span class="p">,</span> <span class="s1">&#39;A3DTABLE&#39;</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_calculate_datasum_with_heap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card given the input data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">_binary_table_byte_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">dout</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>
            <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">dout</span><span class="p">)</span>

            <span class="c1"># Now add in the heap data to the checksum (we can skip any gap</span>
            <span class="c1"># between the table and the heap since it&#39;s all zeros and doesn&#39;t</span>
            <span class="c1"># contribute to the checksum</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This block is still needed because</span>
                <span class="c1"># test_variable_length_table_data leads to ._get_raw_data</span>
                <span class="c1"># returning None which means _get_heap_data doesn&#39;t work.</span>
                <span class="c1"># Which happens when the data is loaded in memory rather than</span>
                <span class="c1"># being unloaded on disk</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">_FormatP</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">coldata</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                            <span class="c1"># coldata should already be byteswapped from the call</span>
                            <span class="c1"># to _binary_table_byte_swap</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coldata</span><span class="p">):</span>
                                <span class="k">continue</span>

                            <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">coldata</span><span class="p">,</span> <span class="n">csum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_get_heap_data</span><span class="p">(),</span> <span class="n">csum</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">csum</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="c1"># This method calculates the datasum while incorporating any</span>
            <span class="c1"># heap data, which is obviously not handled from the base</span>
            <span class="c1"># _calculate_datasum</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum_with_heap</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the case where the data has not been read from the file</span>
            <span class="c1"># yet.  We can handle that in a generic manner so we do it in the</span>
            <span class="c1"># base class.  The other possibility is that there is no data at</span>
            <span class="c1"># all.  This can also be handled in a generic manner.</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_writedata_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size</span>

        <span class="k">with</span> <span class="n">_binary_table_byte_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_has_unicode_fields</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># If the raw data was a user-supplied recarray, we can&#39;t write</span>
                <span class="c1"># unicode columns directly to the file, so we have to switch</span>
                <span class="c1"># to a slower row-by-row write</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writedata_by_row</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c1"># write out the heap of variable length array columns this has</span>
                <span class="c1"># to be done after the &quot;regular&quot; data is written (above)</span>
                <span class="c1"># to avoid a bug in the lustre filesystem client, don&#39;t</span>
                <span class="c1"># write 0-byte objects</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">*</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

            <span class="n">nbytes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_gap</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manages_own_heap</span><span class="p">:</span>
                <span class="c1"># Write the heap data one column at a time, in the order</span>
                <span class="c1"># that the data pointers appear in the column (regardless</span>
                <span class="c1"># if that data pointer has a different, previous heap</span>
                <span class="c1"># offset listed)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                      <span class="n">_FormatP</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">nbytes</span> <span class="o">+=</span> <span class="n">row</span><span class="o">.</span><span class="n">nbytes</span>
                            <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heap_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_heap_data</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nbytes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span>
                    <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">=</span> <span class="n">nbytes</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">_gap</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">nbytes</span>

        <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span>

        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_writedata_by_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span>

        <span class="c1"># Creating Record objects is expensive (as in</span>
        <span class="c1"># `for row in self.data:` so instead we just iterate over the row</span>
        <span class="c1"># indices and get one field at a time:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">field_width</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;U&#39;</span><span class="p">:</span>
                    <span class="c1"># Read the field *width* by reading past the field kind.</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
                    <span class="n">field_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s1">&#39;ascii&#39;</span><span class="p">)</span>

                <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">field_width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
                    <span class="n">item_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="c1"># Fix padding problem (see #5296).</span>
                    <span class="n">padding</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">field_width</span> <span class="o">-</span> <span class="n">item_length</span><span class="p">)</span>
                    <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="n">_tdump_file_format</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">        - **datafile:** Each line of the data file represents one row of table</span>
<span class="s2">          data.  The data is output one column at a time in column order.  If</span>
<span class="s2">          a column contains an array, each element of the column array in the</span>
<span class="s2">          current row is output before moving on to the next column.  Each row</span>
<span class="s2">          ends with a new line.</span>

<span class="s2">          Integer data is output right-justified in a 21-character field</span>
<span class="s2">          followed by a blank.  Floating point data is output right justified</span>
<span class="s2">          using &#39;g&#39; format in a 21-character field with 15 digits of</span>
<span class="s2">          precision, followed by a blank.  String data that does not contain</span>
<span class="s2">          whitespace is output left-justified in a field whose width matches</span>
<span class="s2">          the width specified in the ``TFORM`` header parameter for the</span>
<span class="s2">          column, followed by a blank.  When the string data contains</span>
<span class="s2">          whitespace characters, the string is enclosed in quotation marks</span>
<span class="s2">          (``&quot;&quot;``).  For the last data element in a row, the trailing blank in</span>
<span class="s2">          the field is replaced by a new line character.</span>

<span class="s2">          For column data containing variable length arrays (&#39;P&#39; format), the</span>
<span class="s2">          array data is preceded by the string ``&#39;VLA_Length= &#39;`` and the</span>
<span class="s2">          integer length of the array for that row, left-justified in a</span>
<span class="s2">          21-character field, followed by a blank.</span>

<span class="s2">          .. note::</span>

<span class="s2">              This format does *not* support variable length arrays using the</span>
<span class="s2">              (&#39;Q&#39; format) due to difficult to overcome ambiguities. What this</span>
<span class="s2">              means is that this file format cannot support VLA columns in</span>
<span class="s2">              tables stored in files that are over 2 GB in size.</span>

<span class="s2">          For column data representing a bit field (&#39;X&#39; format), each bit</span>
<span class="s2">          value in the field is output right-justified in a 21-character field</span>
<span class="s2">          as 1 (for true) or 0 (for false).</span>

<span class="s2">        - **cdfile:** Each line of the column definitions file provides the</span>
<span class="s2">          definitions for one column in the table.  The line is broken up into</span>
<span class="s2">          8, sixteen-character fields.  The first field provides the column</span>
<span class="s2">          name (``TTYPEn``).  The second field provides the column format</span>
<span class="s2">          (``TFORMn``).  The third field provides the display format</span>
<span class="s2">          (``TDISPn``).  The fourth field provides the physical units</span>
<span class="s2">          (``TUNITn``).  The fifth field provides the dimensions for a</span>
<span class="s2">          multidimensional array (``TDIMn``).  The sixth field provides the</span>
<span class="s2">          value that signifies an undefined value (``TNULLn``).  The seventh</span>
<span class="s2">          field provides the scale factor (``TSCALn``).  The eighth field</span>
<span class="s2">          provides the offset value (``TZEROn``).  A field value of ``&quot;&quot;`` is</span>
<span class="s2">          used to represent the case where no value is provided.</span>

<span class="s2">        - **hfile:** Each line of the header parameters file provides the</span>
<span class="s2">          definition of a single HDU header card as represented by the card</span>
<span class="s2">          image.</span>
<span class="s2">      &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BinTableHDU.dump"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datafile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dump the table HDU to a file in ASCII format.  The table may be dumped</span>
<span class="sd">        in three separate files, one containing column definitions, one</span>
<span class="sd">        containing header parameters, and one for table data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datafile : path-like or file-like, optional</span>
<span class="sd">            Output data file.  The default is the root name of the</span>
<span class="sd">            fits file associated with this HDU appended with the</span>
<span class="sd">            extension ``.txt``.</span>

<span class="sd">        cdfile : path-like or file-like, optional</span>
<span class="sd">            Output column definitions file.  The default is `None`, no</span>
<span class="sd">            column definitions output is produced.</span>

<span class="sd">        hfile : path-like or file-like, optional</span>
<span class="sd">            Output header parameters file.  The default is `None`,</span>
<span class="sd">            no header parameters output is produced.</span>

<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If ``True``, overwrite the output file if it exists. Raises an</span>
<span class="sd">            ``OSError`` if ``False`` and the output file exists. Default is</span>
<span class="sd">            ``False``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The primary use for the `dump` method is to allow viewing and editing</span>
<span class="sd">        the table data and parameters in a standard text editor.</span>
<span class="sd">        The `load` method can be used to create a new table from the three</span>
<span class="sd">        plain text (ASCII) files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if the output files already exist</span>
        <span class="n">exist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="p">,</span> <span class="n">hfile</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">exist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;File &#39;</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&#39; already exists.&quot;</span>
                                     <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">exist</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;  If you mean to &quot;</span>
                                                      <span class="s2">&quot;replace the file(s) &quot;</span>
                                                      <span class="s2">&quot;then use the argument &quot;</span>
                                                      <span class="s2">&quot;&#39;overwrite=True&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Process the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dump_data</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span>

        <span class="c1"># Process the column definitions</span>
        <span class="k">if</span> <span class="n">cdfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dump_coldefs</span><span class="p">(</span><span class="n">cdfile</span><span class="p">)</span>

        <span class="c1"># Process the header parameters</span>
        <span class="k">if</span> <span class="n">hfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dump</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dump</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">_tdump_file_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">        &#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BinTableHDU.load"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a table from the input ASCII files.  The input is from up to</span>
<span class="sd">        three separate files, one containing column definitions, one containing</span>
<span class="sd">        header parameters, and one containing column data.</span>

<span class="sd">        The column definition and header parameters files are not required.</span>
<span class="sd">        When absent the column definitions and/or header parameters are taken</span>
<span class="sd">        from the header object given in the header argument; otherwise sensible</span>
<span class="sd">        defaults are inferred (though this mode is not recommended).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datafile : path-like or file-like</span>
<span class="sd">            Input data file containing the table data in ASCII format.</span>

<span class="sd">        cdfile : path-like or file-like, optional</span>
<span class="sd">            Input column definition file containing the names,</span>
<span class="sd">            formats, display formats, physical units, multidimensional</span>
<span class="sd">            array dimensions, undefined values, scale factors, and</span>
<span class="sd">            offsets associated with the columns in the table.  If</span>
<span class="sd">            `None`, the column definitions are taken from the current</span>
<span class="sd">            values in this object.</span>

<span class="sd">        hfile : path-like or file-like, optional</span>
<span class="sd">            Input parameter definition file containing the header</span>
<span class="sd">            parameter definitions to be associated with the table.  If</span>
<span class="sd">            `None`, the header parameter definitions are taken from</span>
<span class="sd">            the current values in this objects header.</span>

<span class="sd">        replace : bool, optional</span>
<span class="sd">            When `True`, indicates that the entire header should be</span>
<span class="sd">            replaced with the contents of the ASCII file instead of</span>
<span class="sd">            just updating the current header.</span>

<span class="sd">        header : `~astropy.io.fits.Header`, optional</span>
<span class="sd">            When the cdfile and hfile are missing, use this Header object in</span>
<span class="sd">            the creation of the new table and HDU.  Otherwise this Header</span>
<span class="sd">            supersedes the keywords from hfile, which is only used to update</span>
<span class="sd">            values not present in this Header, unless ``replace=True`` in which</span>
<span class="sd">            this Header&#39;s values are completely replaced with the values from</span>
<span class="sd">            hfile.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The primary use for the `load` method is to allow the input of ASCII</span>
<span class="sd">        data that was edited in a standard text editor of the table data and</span>
<span class="sd">        parameters.  The `dump` method can be used to create the initial ASCII</span>
<span class="sd">        files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Process the parameter file</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">hfile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">fromtextfile</span><span class="p">(</span><span class="n">hfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Header</span><span class="o">.</span><span class="n">fromtextfile</span><span class="p">(</span><span class="n">hfile</span><span class="p">),</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">update_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">coldefs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Process the column definitions file</span>
        <span class="k">if</span> <span class="n">cdfile</span><span class="p">:</span>
            <span class="n">coldefs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load_coldefs</span><span class="p">(</span><span class="n">cdfile</span><span class="p">)</span>

        <span class="c1"># Process the data file</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">coldefs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coldefs</span> <span class="o">=</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Create a new HDU using the supplied header and data</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">coldefs</span>
        <span class="k">return</span> <span class="n">hdu</span></div>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">load</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">load</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">_tdump_file_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">        &#39;</span><span class="p">)</span>

    <span class="n">load</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
    <span class="c1"># Have to create a classmethod from this here instead of as a decorator;</span>
    <span class="c1"># otherwise we can&#39;t update __doc__</span>

    <span class="k">def</span> <span class="nf">_dump_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the table data in the ASCII format read by BinTableHDU.load()</span>
<span class="sd">        to fileobj.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">linewriter</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>

        <span class="c1"># Process each row of the table and output one row at a time</span>
        <span class="k">def</span> <span class="nf">format_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">format</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">itemsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">return</span> <span class="s1">&#39;{:</span><span class="si">{size}</span><span class="s1">}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;AllInteger&#39;</span><span class="p">]:</span>
                <span class="c1"># output integer</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s1">21d</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">elif</span> <span class="nb">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;Complex&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">real</span><span class="si">:</span><span class="s1">21.15g</span><span class="si">}</span><span class="s1">+</span><span class="si">{</span><span class="n">val</span><span class="o">.</span><span class="n">imag</span><span class="si">:</span><span class="s1">.15g</span><span class="si">}</span><span class="s1">j&#39;</span>
            <span class="k">elif</span> <span class="nb">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;Float&#39;</span><span class="p">]:</span>
                <span class="c1"># output floating point</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s1">#21.15g</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># the line for this row of the table</span>

            <span class="c1"># Process each column of the row.</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># format of data in a variable length array</span>
                <span class="c1"># where None means it is not a VLA:</span>
                <span class="n">vla_format</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="n">_convert_format</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
                    <span class="c1"># P format means this is a variable length array so output</span>
                    <span class="c1"># the length of the array for this row and set the format</span>
                    <span class="c1"># for the VLA data</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;VLA_Length=&#39;</span><span class="p">)</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">])</span><span class="si">:</span><span class="s1">21d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">option</span> <span class="o">=</span> <span class="n">_parse_tformat</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
                    <span class="n">vla_format</span> <span class="o">=</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">vla_format</span><span class="p">:</span>
                    <span class="c1"># Output the data for each element in the array</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">vla_format</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The column data is a single element</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">array_format</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
                    <span class="k">if</span> <span class="n">array_format</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
                        <span class="n">array_format</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">char</span>
                    <span class="k">if</span> <span class="n">array_format</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                        <span class="n">array_format</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                            <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array_format</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                                    <span class="n">array_format</span><span class="p">))</span>
            <span class="n">linewriter</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_dump_coldefs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the column definition parameters in the ASCII format read by</span>
<span class="sd">        BinTableHDU.load() to fileobj.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Process each column of the table and output the result to the</span>
        <span class="c1"># file one at a time</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">]</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;dim&#39;</span><span class="p">,</span> <span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="s1">&#39;bscale&#39;</span><span class="p">,</span> <span class="s1">&#39;bzero&#39;</span><span class="p">]</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{!s:16s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)]</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">coldefs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the table data from the ASCII file output by BinTableHDU.dump().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">initialpos</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>  <span class="c1"># We&#39;ll be returning here later</span>
        <span class="n">linereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>

        <span class="c1"># First we need to do some preprocessing on the file to find out how</span>
        <span class="c1"># much memory we&#39;ll need to reserve for the table.  This is necessary</span>
        <span class="c1"># even if we already have the coldefs in order to determine how many</span>
        <span class="c1"># rows to reserve memory for</span>
        <span class="n">vla_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">recformats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recformats</span> <span class="o">=</span> <span class="n">coldefs</span><span class="o">.</span><span class="n">_recformats</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">coldefs</span><span class="o">.</span><span class="n">names</span>

        <span class="k">def</span> <span class="nf">update_recformats</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="n">fitsformat</span> <span class="o">=</span> <span class="n">_scalar_to_format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="n">_convert_format</span><span class="p">(</span><span class="n">fitsformat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recformats</span><span class="p">):</span>
                <span class="n">recformats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recformat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_cmp_recformats</span><span class="p">(</span><span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">recformat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">recformat</span>

        <span class="c1"># TODO: The handling of VLAs could probably be simplified a bit</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">linereader</span><span class="p">:</span>
            <span class="n">nrows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;VLA_Length=&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
                        <span class="n">vla_length</span> <span class="o">=</span> <span class="n">vla_lengths</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vla_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">vla_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vla_length</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="k">while</span> <span class="n">vla_length</span><span class="p">:</span>
                        <span class="n">update_recformats</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">col</span><span class="p">)</span>
                        <span class="n">vla_length</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
                        <span class="n">vla_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">update_recformats</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">col</span><span class="p">)</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Update the recformats for any VLAs</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">format_parser</span><span class="p">(</span><span class="n">recformats</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># TODO: In the future maybe enable loading a bit at a time so that we</span>
        <span class="c1"># can convert from this format to an actual FITS file on disk without</span>
        <span class="c1"># needing enough physical memory to hold the entire thing at once</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
                                       <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># TODO: It seems to me a lot of this could/should be handled from</span>
        <span class="c1"># within the FITS_rec class rather than here.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">length</span><span class="p">)):]</span>

                <span class="c1"># NOTE: FormatQ not supported here; it&#39;s hard to determine</span>
                <span class="c1"># whether or not it will be necessary to use a wider descriptor</span>
                <span class="c1"># type. The function documentation will have to serve as a</span>
                <span class="c1"># warning that this is not supported.</span>
                <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_FormatP</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">_cache_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_makep</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="c1"># Special formatting for a couple particular data types</span>
            <span class="k">if</span> <span class="n">recformats</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">recformats</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]:</span>
                <span class="c1"># For some reason, in arrays/fields where numpy expects a</span>
                <span class="c1"># complex it&#39;s not happy to take a string representation</span>
                <span class="c1"># (though it&#39;s happy to do that in other contexts), so we have</span>
                <span class="c1"># to convert the string representation for it:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span>

        <span class="c1"># Jump back to the start of the data and create a new line reader</span>
        <span class="n">fileobj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">initialpos</span><span class="p">)</span>
        <span class="n">linereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linereader</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;VLA_Length=&#39;</span><span class="p">:</span>
                    <span class="n">vla_len</span> <span class="o">=</span> <span class="n">vla_lengths</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">vla_len</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">vla_len</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">vla_len</span>
                <span class="k">elif</span> <span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="c1"># This is an array column</span>
                    <span class="n">array_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">array_size</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">array_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">slice_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># This is a scalar row element</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                                              <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="n">slice_</span><span class="p">]]</span>

                <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_coldefs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the table column definitions from the ASCII file output by</span>
<span class="sd">        BinTableHDU.dump().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fileobj</span><span class="p">:</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;format&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;dim&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;null&#39;</span><span class="p">,</span> <span class="s1">&#39;bscale&#39;</span><span class="p">,</span> <span class="s1">&#39;bzero&#39;</span><span class="p">]:</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">word</span><span class="p">:</span>
                    <span class="n">word</span> <span class="o">=</span> <span class="n">_str_to_num</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span></div>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">_binary_table_byte_swap</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensures that all the data of a binary FITS table (represented as a FITS_rec</span>
<span class="sd">    object) is in a big-endian byte order.  Columns are swapped in-place one</span>
<span class="sd">    at a time, and then returned to their previous byte order when this context</span>
<span class="sd">    manager exits.</span>

<span class="sd">    Because a new dtype is needed to represent the byte-swapped columns, the</span>
<span class="sd">    new dtype is temporarily applied as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">formats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">to_swap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">:</span>
        <span class="n">swap_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swap_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orig_dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">_get_recarray_field</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="n">field_dtype</span><span class="p">,</span> <span class="n">field_offset</span> <span class="o">=</span> <span class="n">orig_dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_dtype</span><span class="p">)</span>
        <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_offset</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># only swap unswapped</span>
        <span class="c1"># must use field_dtype.base here since for multi-element dtypes,</span>
        <span class="c1"># the .str with be &#39;|V&lt;N&gt;&#39; where &lt;N&gt; is the total bytes per element</span>
        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">field_dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">swap_types</span><span class="p">:</span>
            <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="c1"># Override the dtype for this field in the new record dtype with</span>
            <span class="c1"># the byteswapped version</span>
            <span class="n">formats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span>

        <span class="c1"># deal with var length table</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recformat</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
            <span class="n">coldata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coldata</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">swap_types</span><span class="p">):</span>
                    <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">to_swap</span><span class="p">):</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">({</span><span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span>
                           <span class="s1">&#39;formats&#39;</span><span class="p">:</span> <span class="n">formats</span><span class="p">,</span>
                           <span class="s1">&#39;offsets&#39;</span><span class="p">:</span> <span class="n">offsets</span><span class="p">})</span>

    <span class="k">yield</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">to_swap</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">orig_dtype</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 20112022, The Astropy Developers.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 3.5.4. &nbsp;
    Last built 09 May 2022. <br/>
  </p>
</footer>
  </body>
</html>